// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"opencensus/core/ent/bedrecord"
	"opencensus/core/ent/district"
	"opencensus/core/ent/organization"
	"opencensus/core/ent/oxygenrecord"
	"opencensus/core/ent/predicate"
	"opencensus/core/ent/province"
	"opencensus/core/ent/region"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBedRecord    = "BedRecord"
	TypeDistrict     = "District"
	TypeOrganization = "Organization"
	TypeOxygenRecord = "OxygenRecord"
	TypeProvince     = "Province"
	TypeRegion       = "Region"
)

// BedRecordMutation represents an operation that mutates the BedRecord nodes in the graph.
type BedRecordMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	busyCovidBeds         *int
	addbusyCovidBeds      *int
	availableCovidBeds    *int
	addavailableCovidBeds *int
	clearedFields         map[string]struct{}
	organization          map[int]struct{}
	removedorganization   map[int]struct{}
	clearedorganization   bool
	done                  bool
	oldValue              func(context.Context) (*BedRecord, error)
	predicates            []predicate.BedRecord
}

var _ ent.Mutation = (*BedRecordMutation)(nil)

// bedrecordOption allows management of the mutation configuration using functional options.
type bedrecordOption func(*BedRecordMutation)

// newBedRecordMutation creates new mutation for the BedRecord entity.
func newBedRecordMutation(c config, op Op, opts ...bedrecordOption) *BedRecordMutation {
	m := &BedRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeBedRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBedRecordID sets the ID field of the mutation.
func withBedRecordID(id int) bedrecordOption {
	return func(m *BedRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *BedRecord
		)
		m.oldValue = func(ctx context.Context) (*BedRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BedRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBedRecord sets the old BedRecord of the mutation.
func withBedRecord(node *BedRecord) bedrecordOption {
	return func(m *BedRecordMutation) {
		m.oldValue = func(context.Context) (*BedRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BedRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BedRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BedRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBusyCovidBeds sets the "busyCovidBeds" field.
func (m *BedRecordMutation) SetBusyCovidBeds(i int) {
	m.busyCovidBeds = &i
	m.addbusyCovidBeds = nil
}

// BusyCovidBeds returns the value of the "busyCovidBeds" field in the mutation.
func (m *BedRecordMutation) BusyCovidBeds() (r int, exists bool) {
	v := m.busyCovidBeds
	if v == nil {
		return
	}
	return *v, true
}

// OldBusyCovidBeds returns the old "busyCovidBeds" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldBusyCovidBeds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBusyCovidBeds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBusyCovidBeds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusyCovidBeds: %w", err)
	}
	return oldValue.BusyCovidBeds, nil
}

// AddBusyCovidBeds adds i to the "busyCovidBeds" field.
func (m *BedRecordMutation) AddBusyCovidBeds(i int) {
	if m.addbusyCovidBeds != nil {
		*m.addbusyCovidBeds += i
	} else {
		m.addbusyCovidBeds = &i
	}
}

// AddedBusyCovidBeds returns the value that was added to the "busyCovidBeds" field in this mutation.
func (m *BedRecordMutation) AddedBusyCovidBeds() (r int, exists bool) {
	v := m.addbusyCovidBeds
	if v == nil {
		return
	}
	return *v, true
}

// ResetBusyCovidBeds resets all changes to the "busyCovidBeds" field.
func (m *BedRecordMutation) ResetBusyCovidBeds() {
	m.busyCovidBeds = nil
	m.addbusyCovidBeds = nil
}

// SetAvailableCovidBeds sets the "availableCovidBeds" field.
func (m *BedRecordMutation) SetAvailableCovidBeds(i int) {
	m.availableCovidBeds = &i
	m.addavailableCovidBeds = nil
}

// AvailableCovidBeds returns the value of the "availableCovidBeds" field in the mutation.
func (m *BedRecordMutation) AvailableCovidBeds() (r int, exists bool) {
	v := m.availableCovidBeds
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableCovidBeds returns the old "availableCovidBeds" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldAvailableCovidBeds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvailableCovidBeds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvailableCovidBeds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableCovidBeds: %w", err)
	}
	return oldValue.AvailableCovidBeds, nil
}

// AddAvailableCovidBeds adds i to the "availableCovidBeds" field.
func (m *BedRecordMutation) AddAvailableCovidBeds(i int) {
	if m.addavailableCovidBeds != nil {
		*m.addavailableCovidBeds += i
	} else {
		m.addavailableCovidBeds = &i
	}
}

// AddedAvailableCovidBeds returns the value that was added to the "availableCovidBeds" field in this mutation.
func (m *BedRecordMutation) AddedAvailableCovidBeds() (r int, exists bool) {
	v := m.addavailableCovidBeds
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableCovidBeds resets all changes to the "availableCovidBeds" field.
func (m *BedRecordMutation) ResetAvailableCovidBeds() {
	m.availableCovidBeds = nil
	m.addavailableCovidBeds = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *BedRecordMutation) AddOrganizationIDs(ids ...int) {
	if m.organization == nil {
		m.organization = make(map[int]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *BedRecordMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the "organization" edge to the Organization entity was cleared.
func (m *BedRecordMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *BedRecordMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *BedRecordMutation) RemovedOrganizationIDs() (ids []int) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *BedRecordMutation) OrganizationIDs() (ids []int) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *BedRecordMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// Op returns the operation name.
func (m *BedRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BedRecord).
func (m *BedRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BedRecordMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.busyCovidBeds != nil {
		fields = append(fields, bedrecord.FieldBusyCovidBeds)
	}
	if m.availableCovidBeds != nil {
		fields = append(fields, bedrecord.FieldAvailableCovidBeds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BedRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bedrecord.FieldBusyCovidBeds:
		return m.BusyCovidBeds()
	case bedrecord.FieldAvailableCovidBeds:
		return m.AvailableCovidBeds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BedRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bedrecord.FieldBusyCovidBeds:
		return m.OldBusyCovidBeds(ctx)
	case bedrecord.FieldAvailableCovidBeds:
		return m.OldAvailableCovidBeds(ctx)
	}
	return nil, fmt.Errorf("unknown BedRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BedRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bedrecord.FieldBusyCovidBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusyCovidBeds(v)
		return nil
	case bedrecord.FieldAvailableCovidBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableCovidBeds(v)
		return nil
	}
	return fmt.Errorf("unknown BedRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BedRecordMutation) AddedFields() []string {
	var fields []string
	if m.addbusyCovidBeds != nil {
		fields = append(fields, bedrecord.FieldBusyCovidBeds)
	}
	if m.addavailableCovidBeds != nil {
		fields = append(fields, bedrecord.FieldAvailableCovidBeds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BedRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bedrecord.FieldBusyCovidBeds:
		return m.AddedBusyCovidBeds()
	case bedrecord.FieldAvailableCovidBeds:
		return m.AddedAvailableCovidBeds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BedRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bedrecord.FieldBusyCovidBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusyCovidBeds(v)
		return nil
	case bedrecord.FieldAvailableCovidBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableCovidBeds(v)
		return nil
	}
	return fmt.Errorf("unknown BedRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BedRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BedRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BedRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BedRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BedRecordMutation) ResetField(name string) error {
	switch name {
	case bedrecord.FieldBusyCovidBeds:
		m.ResetBusyCovidBeds()
		return nil
	case bedrecord.FieldAvailableCovidBeds:
		m.ResetAvailableCovidBeds()
		return nil
	}
	return fmt.Errorf("unknown BedRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BedRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, bedrecord.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BedRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bedrecord.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BedRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganization != nil {
		edges = append(edges, bedrecord.EdgeOrganization)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BedRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bedrecord.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BedRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, bedrecord.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BedRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case bedrecord.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BedRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BedRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BedRecordMutation) ResetEdge(name string) error {
	switch name {
	case bedrecord.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown BedRecord edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	clearedFields       map[string]struct{}
	organization        map[int]struct{}
	removedorganization map[int]struct{}
	clearedorganization bool
	province            map[int]struct{}
	removedprovince     map[int]struct{}
	clearedprovince     bool
	done                bool
	oldValue            func(context.Context) (*District, error)
	predicates          []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id int) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DistrictMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *DistrictMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DistrictMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DistrictMutation) ResetName() {
	m.name = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *DistrictMutation) AddOrganizationIDs(ids ...int) {
	if m.organization == nil {
		m.organization = make(map[int]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DistrictMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the "organization" edge to the Organization entity was cleared.
func (m *DistrictMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *DistrictMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *DistrictMutation) RemovedOrganizationIDs() (ids []int) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *DistrictMutation) OrganizationIDs() (ids []int) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DistrictMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddProvinceIDs adds the "province" edge to the Province entity by ids.
func (m *DistrictMutation) AddProvinceIDs(ids ...int) {
	if m.province == nil {
		m.province = make(map[int]struct{})
	}
	for i := range ids {
		m.province[ids[i]] = struct{}{}
	}
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *DistrictMutation) ClearProvince() {
	m.clearedprovince = true
}

// ProvinceCleared returns if the "province" edge to the Province entity was cleared.
func (m *DistrictMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// RemoveProvinceIDs removes the "province" edge to the Province entity by IDs.
func (m *DistrictMutation) RemoveProvinceIDs(ids ...int) {
	if m.removedprovince == nil {
		m.removedprovince = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovince[ids[i]] = struct{}{}
	}
}

// RemovedProvince returns the removed IDs of the "province" edge to the Province entity.
func (m *DistrictMutation) RemovedProvinceIDs() (ids []int) {
	for id := range m.removedprovince {
		ids = append(ids, id)
	}
	return
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
func (m *DistrictMutation) ProvinceIDs() (ids []int) {
	for id := range m.province {
		ids = append(ids, id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *DistrictMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
	m.removedprovince = nil
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, district.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, district.EdgeOrganization)
	}
	if m.province != nil {
		edges = append(edges, district.EdgeProvince)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeProvince:
		ids := make([]ent.Value, 0, len(m.province))
		for id := range m.province {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorganization != nil {
		edges = append(edges, district.EdgeOrganization)
	}
	if m.removedprovince != nil {
		edges = append(edges, district.EdgeProvince)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeProvince:
		ids := make([]ent.Value, 0, len(m.removedprovince))
		for id := range m.removedprovince {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, district.EdgeOrganization)
	}
	if m.clearedprovince {
		edges = append(edges, district.EdgeProvince)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeOrganization:
		return m.clearedorganization
	case district.EdgeProvince:
		return m.clearedprovince
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case district.EdgeProvince:
		m.ResetProvince()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	code                 *string
	ubigeo               *string
	kind                 *string
	covidZone            *bool
	category             *string
	clearedFields        map[string]struct{}
	region               map[int]struct{}
	removedregion        map[int]struct{}
	clearedregion        bool
	province             map[int]struct{}
	removedprovince      map[int]struct{}
	clearedprovince      bool
	district             map[int]struct{}
	removeddistrict      map[int]struct{}
	cleareddistrict      bool
	oxygenRecords        map[int]struct{}
	removedoxygenRecords map[int]struct{}
	clearedoxygenRecords bool
	bedRecords           map[int]struct{}
	removedbedRecords    map[int]struct{}
	clearedbedRecords    bool
	done                 bool
	oldValue             func(context.Context) (*Organization, error)
	predicates           []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *OrganizationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrganizationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *OrganizationMutation) ResetCode() {
	m.code = nil
}

// SetUbigeo sets the "ubigeo" field.
func (m *OrganizationMutation) SetUbigeo(s string) {
	m.ubigeo = &s
}

// Ubigeo returns the value of the "ubigeo" field in the mutation.
func (m *OrganizationMutation) Ubigeo() (r string, exists bool) {
	v := m.ubigeo
	if v == nil {
		return
	}
	return *v, true
}

// OldUbigeo returns the old "ubigeo" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUbigeo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUbigeo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUbigeo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUbigeo: %w", err)
	}
	return oldValue.Ubigeo, nil
}

// ResetUbigeo resets all changes to the "ubigeo" field.
func (m *OrganizationMutation) ResetUbigeo() {
	m.ubigeo = nil
}

// SetKind sets the "kind" field.
func (m *OrganizationMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *OrganizationMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *OrganizationMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[organization.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *OrganizationMutation) KindCleared() bool {
	_, ok := m.clearedFields[organization.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *OrganizationMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, organization.FieldKind)
}

// SetCovidZone sets the "covidZone" field.
func (m *OrganizationMutation) SetCovidZone(b bool) {
	m.covidZone = &b
}

// CovidZone returns the value of the "covidZone" field in the mutation.
func (m *OrganizationMutation) CovidZone() (r bool, exists bool) {
	v := m.covidZone
	if v == nil {
		return
	}
	return *v, true
}

// OldCovidZone returns the old "covidZone" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCovidZone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCovidZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCovidZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCovidZone: %w", err)
	}
	return oldValue.CovidZone, nil
}

// ClearCovidZone clears the value of the "covidZone" field.
func (m *OrganizationMutation) ClearCovidZone() {
	m.covidZone = nil
	m.clearedFields[organization.FieldCovidZone] = struct{}{}
}

// CovidZoneCleared returns if the "covidZone" field was cleared in this mutation.
func (m *OrganizationMutation) CovidZoneCleared() bool {
	_, ok := m.clearedFields[organization.FieldCovidZone]
	return ok
}

// ResetCovidZone resets all changes to the "covidZone" field.
func (m *OrganizationMutation) ResetCovidZone() {
	m.covidZone = nil
	delete(m.clearedFields, organization.FieldCovidZone)
}

// SetCategory sets the "category" field.
func (m *OrganizationMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *OrganizationMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *OrganizationMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[organization.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *OrganizationMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[organization.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *OrganizationMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, organization.FieldCategory)
}

// AddRegionIDs adds the "region" edge to the Region entity by ids.
func (m *OrganizationMutation) AddRegionIDs(ids ...int) {
	if m.region == nil {
		m.region = make(map[int]struct{})
	}
	for i := range ids {
		m.region[ids[i]] = struct{}{}
	}
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *OrganizationMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared returns if the "region" edge to the Region entity was cleared.
func (m *OrganizationMutation) RegionCleared() bool {
	return m.clearedregion
}

// RemoveRegionIDs removes the "region" edge to the Region entity by IDs.
func (m *OrganizationMutation) RemoveRegionIDs(ids ...int) {
	if m.removedregion == nil {
		m.removedregion = make(map[int]struct{})
	}
	for i := range ids {
		m.removedregion[ids[i]] = struct{}{}
	}
}

// RemovedRegion returns the removed IDs of the "region" edge to the Region entity.
func (m *OrganizationMutation) RemovedRegionIDs() (ids []int) {
	for id := range m.removedregion {
		ids = append(ids, id)
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
func (m *OrganizationMutation) RegionIDs() (ids []int) {
	for id := range m.region {
		ids = append(ids, id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *OrganizationMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
	m.removedregion = nil
}

// AddProvinceIDs adds the "province" edge to the Province entity by ids.
func (m *OrganizationMutation) AddProvinceIDs(ids ...int) {
	if m.province == nil {
		m.province = make(map[int]struct{})
	}
	for i := range ids {
		m.province[ids[i]] = struct{}{}
	}
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *OrganizationMutation) ClearProvince() {
	m.clearedprovince = true
}

// ProvinceCleared returns if the "province" edge to the Province entity was cleared.
func (m *OrganizationMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// RemoveProvinceIDs removes the "province" edge to the Province entity by IDs.
func (m *OrganizationMutation) RemoveProvinceIDs(ids ...int) {
	if m.removedprovince == nil {
		m.removedprovince = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovince[ids[i]] = struct{}{}
	}
}

// RemovedProvince returns the removed IDs of the "province" edge to the Province entity.
func (m *OrganizationMutation) RemovedProvinceIDs() (ids []int) {
	for id := range m.removedprovince {
		ids = append(ids, id)
	}
	return
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
func (m *OrganizationMutation) ProvinceIDs() (ids []int) {
	for id := range m.province {
		ids = append(ids, id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *OrganizationMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
	m.removedprovince = nil
}

// AddDistrictIDs adds the "district" edge to the District entity by ids.
func (m *OrganizationMutation) AddDistrictIDs(ids ...int) {
	if m.district == nil {
		m.district = make(map[int]struct{})
	}
	for i := range ids {
		m.district[ids[i]] = struct{}{}
	}
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *OrganizationMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared returns if the "district" edge to the District entity was cleared.
func (m *OrganizationMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// RemoveDistrictIDs removes the "district" edge to the District entity by IDs.
func (m *OrganizationMutation) RemoveDistrictIDs(ids ...int) {
	if m.removeddistrict == nil {
		m.removeddistrict = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddistrict[ids[i]] = struct{}{}
	}
}

// RemovedDistrict returns the removed IDs of the "district" edge to the District entity.
func (m *OrganizationMutation) RemovedDistrictIDs() (ids []int) {
	for id := range m.removeddistrict {
		ids = append(ids, id)
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
func (m *OrganizationMutation) DistrictIDs() (ids []int) {
	for id := range m.district {
		ids = append(ids, id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *OrganizationMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
	m.removeddistrict = nil
}

// AddOxygenRecordIDs adds the "oxygenRecords" edge to the OxygenRecord entity by ids.
func (m *OrganizationMutation) AddOxygenRecordIDs(ids ...int) {
	if m.oxygenRecords == nil {
		m.oxygenRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.oxygenRecords[ids[i]] = struct{}{}
	}
}

// ClearOxygenRecords clears the "oxygenRecords" edge to the OxygenRecord entity.
func (m *OrganizationMutation) ClearOxygenRecords() {
	m.clearedoxygenRecords = true
}

// OxygenRecordsCleared returns if the "oxygenRecords" edge to the OxygenRecord entity was cleared.
func (m *OrganizationMutation) OxygenRecordsCleared() bool {
	return m.clearedoxygenRecords
}

// RemoveOxygenRecordIDs removes the "oxygenRecords" edge to the OxygenRecord entity by IDs.
func (m *OrganizationMutation) RemoveOxygenRecordIDs(ids ...int) {
	if m.removedoxygenRecords == nil {
		m.removedoxygenRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoxygenRecords[ids[i]] = struct{}{}
	}
}

// RemovedOxygenRecords returns the removed IDs of the "oxygenRecords" edge to the OxygenRecord entity.
func (m *OrganizationMutation) RemovedOxygenRecordsIDs() (ids []int) {
	for id := range m.removedoxygenRecords {
		ids = append(ids, id)
	}
	return
}

// OxygenRecordsIDs returns the "oxygenRecords" edge IDs in the mutation.
func (m *OrganizationMutation) OxygenRecordsIDs() (ids []int) {
	for id := range m.oxygenRecords {
		ids = append(ids, id)
	}
	return
}

// ResetOxygenRecords resets all changes to the "oxygenRecords" edge.
func (m *OrganizationMutation) ResetOxygenRecords() {
	m.oxygenRecords = nil
	m.clearedoxygenRecords = false
	m.removedoxygenRecords = nil
}

// AddBedRecordIDs adds the "bedRecords" edge to the BedRecord entity by ids.
func (m *OrganizationMutation) AddBedRecordIDs(ids ...int) {
	if m.bedRecords == nil {
		m.bedRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.bedRecords[ids[i]] = struct{}{}
	}
}

// ClearBedRecords clears the "bedRecords" edge to the BedRecord entity.
func (m *OrganizationMutation) ClearBedRecords() {
	m.clearedbedRecords = true
}

// BedRecordsCleared returns if the "bedRecords" edge to the BedRecord entity was cleared.
func (m *OrganizationMutation) BedRecordsCleared() bool {
	return m.clearedbedRecords
}

// RemoveBedRecordIDs removes the "bedRecords" edge to the BedRecord entity by IDs.
func (m *OrganizationMutation) RemoveBedRecordIDs(ids ...int) {
	if m.removedbedRecords == nil {
		m.removedbedRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbedRecords[ids[i]] = struct{}{}
	}
}

// RemovedBedRecords returns the removed IDs of the "bedRecords" edge to the BedRecord entity.
func (m *OrganizationMutation) RemovedBedRecordsIDs() (ids []int) {
	for id := range m.removedbedRecords {
		ids = append(ids, id)
	}
	return
}

// BedRecordsIDs returns the "bedRecords" edge IDs in the mutation.
func (m *OrganizationMutation) BedRecordsIDs() (ids []int) {
	for id := range m.bedRecords {
		ids = append(ids, id)
	}
	return
}

// ResetBedRecords resets all changes to the "bedRecords" edge.
func (m *OrganizationMutation) ResetBedRecords() {
	m.bedRecords = nil
	m.clearedbedRecords = false
	m.removedbedRecords = nil
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.code != nil {
		fields = append(fields, organization.FieldCode)
	}
	if m.ubigeo != nil {
		fields = append(fields, organization.FieldUbigeo)
	}
	if m.kind != nil {
		fields = append(fields, organization.FieldKind)
	}
	if m.covidZone != nil {
		fields = append(fields, organization.FieldCovidZone)
	}
	if m.category != nil {
		fields = append(fields, organization.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldCode:
		return m.Code()
	case organization.FieldUbigeo:
		return m.Ubigeo()
	case organization.FieldKind:
		return m.Kind()
	case organization.FieldCovidZone:
		return m.CovidZone()
	case organization.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldCode:
		return m.OldCode(ctx)
	case organization.FieldUbigeo:
		return m.OldUbigeo(ctx)
	case organization.FieldKind:
		return m.OldKind(ctx)
	case organization.FieldCovidZone:
		return m.OldCovidZone(ctx)
	case organization.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case organization.FieldUbigeo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUbigeo(v)
		return nil
	case organization.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case organization.FieldCovidZone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCovidZone(v)
		return nil
	case organization.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldKind) {
		fields = append(fields, organization.FieldKind)
	}
	if m.FieldCleared(organization.FieldCovidZone) {
		fields = append(fields, organization.FieldCovidZone)
	}
	if m.FieldCleared(organization.FieldCategory) {
		fields = append(fields, organization.FieldCategory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldKind:
		m.ClearKind()
		return nil
	case organization.FieldCovidZone:
		m.ClearCovidZone()
		return nil
	case organization.FieldCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldCode:
		m.ResetCode()
		return nil
	case organization.FieldUbigeo:
		m.ResetUbigeo()
		return nil
	case organization.FieldKind:
		m.ResetKind()
		return nil
	case organization.FieldCovidZone:
		m.ResetCovidZone()
		return nil
	case organization.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.region != nil {
		edges = append(edges, organization.EdgeRegion)
	}
	if m.province != nil {
		edges = append(edges, organization.EdgeProvince)
	}
	if m.district != nil {
		edges = append(edges, organization.EdgeDistrict)
	}
	if m.oxygenRecords != nil {
		edges = append(edges, organization.EdgeOxygenRecords)
	}
	if m.bedRecords != nil {
		edges = append(edges, organization.EdgeBedRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeRegion:
		ids := make([]ent.Value, 0, len(m.region))
		for id := range m.region {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeProvince:
		ids := make([]ent.Value, 0, len(m.province))
		for id := range m.province {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeDistrict:
		ids := make([]ent.Value, 0, len(m.district))
		for id := range m.district {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOxygenRecords:
		ids := make([]ent.Value, 0, len(m.oxygenRecords))
		for id := range m.oxygenRecords {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeBedRecords:
		ids := make([]ent.Value, 0, len(m.bedRecords))
		for id := range m.bedRecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedregion != nil {
		edges = append(edges, organization.EdgeRegion)
	}
	if m.removedprovince != nil {
		edges = append(edges, organization.EdgeProvince)
	}
	if m.removeddistrict != nil {
		edges = append(edges, organization.EdgeDistrict)
	}
	if m.removedoxygenRecords != nil {
		edges = append(edges, organization.EdgeOxygenRecords)
	}
	if m.removedbedRecords != nil {
		edges = append(edges, organization.EdgeBedRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeRegion:
		ids := make([]ent.Value, 0, len(m.removedregion))
		for id := range m.removedregion {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeProvince:
		ids := make([]ent.Value, 0, len(m.removedprovince))
		for id := range m.removedprovince {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeDistrict:
		ids := make([]ent.Value, 0, len(m.removeddistrict))
		for id := range m.removeddistrict {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOxygenRecords:
		ids := make([]ent.Value, 0, len(m.removedoxygenRecords))
		for id := range m.removedoxygenRecords {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeBedRecords:
		ids := make([]ent.Value, 0, len(m.removedbedRecords))
		for id := range m.removedbedRecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedregion {
		edges = append(edges, organization.EdgeRegion)
	}
	if m.clearedprovince {
		edges = append(edges, organization.EdgeProvince)
	}
	if m.cleareddistrict {
		edges = append(edges, organization.EdgeDistrict)
	}
	if m.clearedoxygenRecords {
		edges = append(edges, organization.EdgeOxygenRecords)
	}
	if m.clearedbedRecords {
		edges = append(edges, organization.EdgeBedRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeRegion:
		return m.clearedregion
	case organization.EdgeProvince:
		return m.clearedprovince
	case organization.EdgeDistrict:
		return m.cleareddistrict
	case organization.EdgeOxygenRecords:
		return m.clearedoxygenRecords
	case organization.EdgeBedRecords:
		return m.clearedbedRecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeRegion:
		m.ResetRegion()
		return nil
	case organization.EdgeProvince:
		m.ResetProvince()
		return nil
	case organization.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case organization.EdgeOxygenRecords:
		m.ResetOxygenRecords()
		return nil
	case organization.EdgeBedRecords:
		m.ResetBedRecords()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OxygenRecordMutation represents an operation that mutates the OxygenRecord nodes in the graph.
type OxygenRecordMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	totalCylinders       *int
	addtotalCylinders    *int
	totalOwnCylinders    *int
	addtotalOwnCylinders *int
	clearedFields        map[string]struct{}
	organization         map[int]struct{}
	removedorganization  map[int]struct{}
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*OxygenRecord, error)
	predicates           []predicate.OxygenRecord
}

var _ ent.Mutation = (*OxygenRecordMutation)(nil)

// oxygenrecordOption allows management of the mutation configuration using functional options.
type oxygenrecordOption func(*OxygenRecordMutation)

// newOxygenRecordMutation creates new mutation for the OxygenRecord entity.
func newOxygenRecordMutation(c config, op Op, opts ...oxygenrecordOption) *OxygenRecordMutation {
	m := &OxygenRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeOxygenRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOxygenRecordID sets the ID field of the mutation.
func withOxygenRecordID(id int) oxygenrecordOption {
	return func(m *OxygenRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *OxygenRecord
		)
		m.oldValue = func(ctx context.Context) (*OxygenRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OxygenRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOxygenRecord sets the old OxygenRecord of the mutation.
func withOxygenRecord(node *OxygenRecord) oxygenrecordOption {
	return func(m *OxygenRecordMutation) {
		m.oldValue = func(context.Context) (*OxygenRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OxygenRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OxygenRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OxygenRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTotalCylinders sets the "totalCylinders" field.
func (m *OxygenRecordMutation) SetTotalCylinders(i int) {
	m.totalCylinders = &i
	m.addtotalCylinders = nil
}

// TotalCylinders returns the value of the "totalCylinders" field in the mutation.
func (m *OxygenRecordMutation) TotalCylinders() (r int, exists bool) {
	v := m.totalCylinders
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCylinders returns the old "totalCylinders" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldTotalCylinders(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalCylinders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalCylinders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCylinders: %w", err)
	}
	return oldValue.TotalCylinders, nil
}

// AddTotalCylinders adds i to the "totalCylinders" field.
func (m *OxygenRecordMutation) AddTotalCylinders(i int) {
	if m.addtotalCylinders != nil {
		*m.addtotalCylinders += i
	} else {
		m.addtotalCylinders = &i
	}
}

// AddedTotalCylinders returns the value that was added to the "totalCylinders" field in this mutation.
func (m *OxygenRecordMutation) AddedTotalCylinders() (r int, exists bool) {
	v := m.addtotalCylinders
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCylinders resets all changes to the "totalCylinders" field.
func (m *OxygenRecordMutation) ResetTotalCylinders() {
	m.totalCylinders = nil
	m.addtotalCylinders = nil
}

// SetTotalOwnCylinders sets the "totalOwnCylinders" field.
func (m *OxygenRecordMutation) SetTotalOwnCylinders(i int) {
	m.totalOwnCylinders = &i
	m.addtotalOwnCylinders = nil
}

// TotalOwnCylinders returns the value of the "totalOwnCylinders" field in the mutation.
func (m *OxygenRecordMutation) TotalOwnCylinders() (r int, exists bool) {
	v := m.totalOwnCylinders
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalOwnCylinders returns the old "totalOwnCylinders" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldTotalOwnCylinders(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalOwnCylinders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalOwnCylinders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalOwnCylinders: %w", err)
	}
	return oldValue.TotalOwnCylinders, nil
}

// AddTotalOwnCylinders adds i to the "totalOwnCylinders" field.
func (m *OxygenRecordMutation) AddTotalOwnCylinders(i int) {
	if m.addtotalOwnCylinders != nil {
		*m.addtotalOwnCylinders += i
	} else {
		m.addtotalOwnCylinders = &i
	}
}

// AddedTotalOwnCylinders returns the value that was added to the "totalOwnCylinders" field in this mutation.
func (m *OxygenRecordMutation) AddedTotalOwnCylinders() (r int, exists bool) {
	v := m.addtotalOwnCylinders
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalOwnCylinders resets all changes to the "totalOwnCylinders" field.
func (m *OxygenRecordMutation) ResetTotalOwnCylinders() {
	m.totalOwnCylinders = nil
	m.addtotalOwnCylinders = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *OxygenRecordMutation) AddOrganizationIDs(ids ...int) {
	if m.organization == nil {
		m.organization = make(map[int]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OxygenRecordMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the "organization" edge to the Organization entity was cleared.
func (m *OxygenRecordMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *OxygenRecordMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *OxygenRecordMutation) RemovedOrganizationIDs() (ids []int) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *OxygenRecordMutation) OrganizationIDs() (ids []int) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OxygenRecordMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// Op returns the operation name.
func (m *OxygenRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OxygenRecord).
func (m *OxygenRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OxygenRecordMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.totalCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalCylinders)
	}
	if m.totalOwnCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalOwnCylinders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OxygenRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		return m.TotalCylinders()
	case oxygenrecord.FieldTotalOwnCylinders:
		return m.TotalOwnCylinders()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OxygenRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		return m.OldTotalCylinders(ctx)
	case oxygenrecord.FieldTotalOwnCylinders:
		return m.OldTotalOwnCylinders(ctx)
	}
	return nil, fmt.Errorf("unknown OxygenRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OxygenRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCylinders(v)
		return nil
	case oxygenrecord.FieldTotalOwnCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalOwnCylinders(v)
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OxygenRecordMutation) AddedFields() []string {
	var fields []string
	if m.addtotalCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalCylinders)
	}
	if m.addtotalOwnCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalOwnCylinders)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OxygenRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		return m.AddedTotalCylinders()
	case oxygenrecord.FieldTotalOwnCylinders:
		return m.AddedTotalOwnCylinders()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OxygenRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCylinders(v)
		return nil
	case oxygenrecord.FieldTotalOwnCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalOwnCylinders(v)
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OxygenRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OxygenRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OxygenRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OxygenRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OxygenRecordMutation) ResetField(name string) error {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		m.ResetTotalCylinders()
		return nil
	case oxygenrecord.FieldTotalOwnCylinders:
		m.ResetTotalOwnCylinders()
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OxygenRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, oxygenrecord.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OxygenRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oxygenrecord.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OxygenRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganization != nil {
		edges = append(edges, oxygenrecord.EdgeOrganization)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OxygenRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oxygenrecord.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OxygenRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, oxygenrecord.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OxygenRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case oxygenrecord.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OxygenRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OxygenRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OxygenRecordMutation) ResetEdge(name string) error {
	switch name {
	case oxygenrecord.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord edge %s", name)
}

// ProvinceMutation represents an operation that mutates the Province nodes in the graph.
type ProvinceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	clearedFields       map[string]struct{}
	organization        map[int]struct{}
	removedorganization map[int]struct{}
	clearedorganization bool
	region              map[int]struct{}
	removedregion       map[int]struct{}
	clearedregion       bool
	district            map[int]struct{}
	removeddistrict     map[int]struct{}
	cleareddistrict     bool
	done                bool
	oldValue            func(context.Context) (*Province, error)
	predicates          []predicate.Province
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows management of the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for the Province entity.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the ID field of the mutation.
func withProvinceID(id int) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProvinceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProvinceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvinceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvinceMutation) ResetName() {
	m.name = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *ProvinceMutation) AddOrganizationIDs(ids ...int) {
	if m.organization == nil {
		m.organization = make(map[int]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ProvinceMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the "organization" edge to the Organization entity was cleared.
func (m *ProvinceMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *ProvinceMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *ProvinceMutation) RemovedOrganizationIDs() (ids []int) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *ProvinceMutation) OrganizationIDs() (ids []int) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ProvinceMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddRegionIDs adds the "region" edge to the Region entity by ids.
func (m *ProvinceMutation) AddRegionIDs(ids ...int) {
	if m.region == nil {
		m.region = make(map[int]struct{})
	}
	for i := range ids {
		m.region[ids[i]] = struct{}{}
	}
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *ProvinceMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared returns if the "region" edge to the Region entity was cleared.
func (m *ProvinceMutation) RegionCleared() bool {
	return m.clearedregion
}

// RemoveRegionIDs removes the "region" edge to the Region entity by IDs.
func (m *ProvinceMutation) RemoveRegionIDs(ids ...int) {
	if m.removedregion == nil {
		m.removedregion = make(map[int]struct{})
	}
	for i := range ids {
		m.removedregion[ids[i]] = struct{}{}
	}
}

// RemovedRegion returns the removed IDs of the "region" edge to the Region entity.
func (m *ProvinceMutation) RemovedRegionIDs() (ids []int) {
	for id := range m.removedregion {
		ids = append(ids, id)
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
func (m *ProvinceMutation) RegionIDs() (ids []int) {
	for id := range m.region {
		ids = append(ids, id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *ProvinceMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
	m.removedregion = nil
}

// AddDistrictIDs adds the "district" edge to the District entity by ids.
func (m *ProvinceMutation) AddDistrictIDs(ids ...int) {
	if m.district == nil {
		m.district = make(map[int]struct{})
	}
	for i := range ids {
		m.district[ids[i]] = struct{}{}
	}
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *ProvinceMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared returns if the "district" edge to the District entity was cleared.
func (m *ProvinceMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// RemoveDistrictIDs removes the "district" edge to the District entity by IDs.
func (m *ProvinceMutation) RemoveDistrictIDs(ids ...int) {
	if m.removeddistrict == nil {
		m.removeddistrict = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddistrict[ids[i]] = struct{}{}
	}
}

// RemovedDistrict returns the removed IDs of the "district" edge to the District entity.
func (m *ProvinceMutation) RemovedDistrictIDs() (ids []int) {
	for id := range m.removeddistrict {
		ids = append(ids, id)
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
func (m *ProvinceMutation) DistrictIDs() (ids []int) {
	for id := range m.district {
		ids = append(ids, id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *ProvinceMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
	m.removeddistrict = nil
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, province.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.organization != nil {
		edges = append(edges, province.EdgeOrganization)
	}
	if m.region != nil {
		edges = append(edges, province.EdgeRegion)
	}
	if m.district != nil {
		edges = append(edges, province.EdgeDistrict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeRegion:
		ids := make([]ent.Value, 0, len(m.region))
		for id := range m.region {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeDistrict:
		ids := make([]ent.Value, 0, len(m.district))
		for id := range m.district {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorganization != nil {
		edges = append(edges, province.EdgeOrganization)
	}
	if m.removedregion != nil {
		edges = append(edges, province.EdgeRegion)
	}
	if m.removeddistrict != nil {
		edges = append(edges, province.EdgeDistrict)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeRegion:
		ids := make([]ent.Value, 0, len(m.removedregion))
		for id := range m.removedregion {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeDistrict:
		ids := make([]ent.Value, 0, len(m.removeddistrict))
		for id := range m.removeddistrict {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorganization {
		edges = append(edges, province.EdgeOrganization)
	}
	if m.clearedregion {
		edges = append(edges, province.EdgeRegion)
	}
	if m.cleareddistrict {
		edges = append(edges, province.EdgeDistrict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	switch name {
	case province.EdgeOrganization:
		return m.clearedorganization
	case province.EdgeRegion:
		return m.clearedregion
	case province.EdgeDistrict:
		return m.cleareddistrict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	switch name {
	case province.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case province.EdgeRegion:
		m.ResetRegion()
		return nil
	case province.EdgeDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown Province edge %s", name)
}

// RegionMutation represents an operation that mutates the Region nodes in the graph.
type RegionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	clearedFields       map[string]struct{}
	organization        map[int]struct{}
	removedorganization map[int]struct{}
	clearedorganization bool
	province            map[int]struct{}
	removedprovince     map[int]struct{}
	clearedprovince     bool
	done                bool
	oldValue            func(context.Context) (*Region, error)
	predicates          []predicate.Region
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows management of the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for the Region entity.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the ID field of the mutation.
func withRegionID(id int) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RegionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *RegionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RegionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RegionMutation) ResetName() {
	m.name = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *RegionMutation) AddOrganizationIDs(ids ...int) {
	if m.organization == nil {
		m.organization = make(map[int]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RegionMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the "organization" edge to the Organization entity was cleared.
func (m *RegionMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *RegionMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *RegionMutation) RemovedOrganizationIDs() (ids []int) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *RegionMutation) OrganizationIDs() (ids []int) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RegionMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddProvinceIDs adds the "province" edge to the Province entity by ids.
func (m *RegionMutation) AddProvinceIDs(ids ...int) {
	if m.province == nil {
		m.province = make(map[int]struct{})
	}
	for i := range ids {
		m.province[ids[i]] = struct{}{}
	}
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *RegionMutation) ClearProvince() {
	m.clearedprovince = true
}

// ProvinceCleared returns if the "province" edge to the Province entity was cleared.
func (m *RegionMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// RemoveProvinceIDs removes the "province" edge to the Province entity by IDs.
func (m *RegionMutation) RemoveProvinceIDs(ids ...int) {
	if m.removedprovince == nil {
		m.removedprovince = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovince[ids[i]] = struct{}{}
	}
}

// RemovedProvince returns the removed IDs of the "province" edge to the Province entity.
func (m *RegionMutation) RemovedProvinceIDs() (ids []int) {
	for id := range m.removedprovince {
		ids = append(ids, id)
	}
	return
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
func (m *RegionMutation) ProvinceIDs() (ids []int) {
	for id := range m.province {
		ids = append(ids, id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *RegionMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
	m.removedprovince = nil
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, region.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, region.EdgeOrganization)
	}
	if m.province != nil {
		edges = append(edges, region.EdgeProvince)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeProvince:
		ids := make([]ent.Value, 0, len(m.province))
		for id := range m.province {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorganization != nil {
		edges = append(edges, region.EdgeOrganization)
	}
	if m.removedprovince != nil {
		edges = append(edges, region.EdgeProvince)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeProvince:
		ids := make([]ent.Value, 0, len(m.removedprovince))
		for id := range m.removedprovince {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, region.EdgeOrganization)
	}
	if m.clearedprovince {
		edges = append(edges, region.EdgeProvince)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	case region.EdgeOrganization:
		return m.clearedorganization
	case region.EdgeProvince:
		return m.clearedprovince
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case region.EdgeProvince:
		m.ResetProvince()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}
