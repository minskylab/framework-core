// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"opencensus/core/ent/bedrecord"
	"opencensus/core/ent/deathrecord"
	"opencensus/core/ent/district"
	"opencensus/core/ent/infectedrecord"
	"opencensus/core/ent/occurency"
	"opencensus/core/ent/oxygenrecord"
	"opencensus/core/ent/place"
	"opencensus/core/ent/predicate"
	"opencensus/core/ent/province"
	"opencensus/core/ent/region"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBedRecord      = "BedRecord"
	TypeDeathRecord    = "DeathRecord"
	TypeDistrict       = "District"
	TypeInfectedRecord = "InfectedRecord"
	TypeOccurency      = "Occurency"
	TypeOxygenRecord   = "OxygenRecord"
	TypePlace          = "Place"
	TypeProvince       = "Province"
	TypeRegion         = "Region"
)

// BedRecordMutation represents an operation that mutates the BedRecord nodes in the graph.
type BedRecordMutation struct {
	config
	op               Op
	typ              string
	id               *int
	reportedDate     *time.Time
	collectedDate    *time.Time
	busyBeds         *int
	addbusyBeds      *int
	availableBeds    *int
	addavailableBeds *int
	totalBeds        *int
	addtotalBeds     *int
	kindBed          *string
	kindAge          *string
	clearedFields    map[string]struct{}
	places           map[int]struct{}
	removedplaces    map[int]struct{}
	clearedplaces    bool
	done             bool
	oldValue         func(context.Context) (*BedRecord, error)
	predicates       []predicate.BedRecord
}

var _ ent.Mutation = (*BedRecordMutation)(nil)

// bedrecordOption allows management of the mutation configuration using functional options.
type bedrecordOption func(*BedRecordMutation)

// newBedRecordMutation creates new mutation for the BedRecord entity.
func newBedRecordMutation(c config, op Op, opts ...bedrecordOption) *BedRecordMutation {
	m := &BedRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeBedRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBedRecordID sets the ID field of the mutation.
func withBedRecordID(id int) bedrecordOption {
	return func(m *BedRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *BedRecord
		)
		m.oldValue = func(ctx context.Context) (*BedRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BedRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBedRecord sets the old BedRecord of the mutation.
func withBedRecord(node *BedRecord) bedrecordOption {
	return func(m *BedRecordMutation) {
		m.oldValue = func(context.Context) (*BedRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BedRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BedRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BedRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetReportedDate sets the "reportedDate" field.
func (m *BedRecordMutation) SetReportedDate(t time.Time) {
	m.reportedDate = &t
}

// ReportedDate returns the value of the "reportedDate" field in the mutation.
func (m *BedRecordMutation) ReportedDate() (r time.Time, exists bool) {
	v := m.reportedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedDate returns the old "reportedDate" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldReportedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReportedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReportedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedDate: %w", err)
	}
	return oldValue.ReportedDate, nil
}

// ResetReportedDate resets all changes to the "reportedDate" field.
func (m *BedRecordMutation) ResetReportedDate() {
	m.reportedDate = nil
}

// SetCollectedDate sets the "collectedDate" field.
func (m *BedRecordMutation) SetCollectedDate(t time.Time) {
	m.collectedDate = &t
}

// CollectedDate returns the value of the "collectedDate" field in the mutation.
func (m *BedRecordMutation) CollectedDate() (r time.Time, exists bool) {
	v := m.collectedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectedDate returns the old "collectedDate" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldCollectedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCollectedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCollectedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectedDate: %w", err)
	}
	return oldValue.CollectedDate, nil
}

// ResetCollectedDate resets all changes to the "collectedDate" field.
func (m *BedRecordMutation) ResetCollectedDate() {
	m.collectedDate = nil
}

// SetBusyBeds sets the "busyBeds" field.
func (m *BedRecordMutation) SetBusyBeds(i int) {
	m.busyBeds = &i
	m.addbusyBeds = nil
}

// BusyBeds returns the value of the "busyBeds" field in the mutation.
func (m *BedRecordMutation) BusyBeds() (r int, exists bool) {
	v := m.busyBeds
	if v == nil {
		return
	}
	return *v, true
}

// OldBusyBeds returns the old "busyBeds" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldBusyBeds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBusyBeds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBusyBeds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusyBeds: %w", err)
	}
	return oldValue.BusyBeds, nil
}

// AddBusyBeds adds i to the "busyBeds" field.
func (m *BedRecordMutation) AddBusyBeds(i int) {
	if m.addbusyBeds != nil {
		*m.addbusyBeds += i
	} else {
		m.addbusyBeds = &i
	}
}

// AddedBusyBeds returns the value that was added to the "busyBeds" field in this mutation.
func (m *BedRecordMutation) AddedBusyBeds() (r int, exists bool) {
	v := m.addbusyBeds
	if v == nil {
		return
	}
	return *v, true
}

// ResetBusyBeds resets all changes to the "busyBeds" field.
func (m *BedRecordMutation) ResetBusyBeds() {
	m.busyBeds = nil
	m.addbusyBeds = nil
}

// SetAvailableBeds sets the "availableBeds" field.
func (m *BedRecordMutation) SetAvailableBeds(i int) {
	m.availableBeds = &i
	m.addavailableBeds = nil
}

// AvailableBeds returns the value of the "availableBeds" field in the mutation.
func (m *BedRecordMutation) AvailableBeds() (r int, exists bool) {
	v := m.availableBeds
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableBeds returns the old "availableBeds" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldAvailableBeds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvailableBeds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvailableBeds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableBeds: %w", err)
	}
	return oldValue.AvailableBeds, nil
}

// AddAvailableBeds adds i to the "availableBeds" field.
func (m *BedRecordMutation) AddAvailableBeds(i int) {
	if m.addavailableBeds != nil {
		*m.addavailableBeds += i
	} else {
		m.addavailableBeds = &i
	}
}

// AddedAvailableBeds returns the value that was added to the "availableBeds" field in this mutation.
func (m *BedRecordMutation) AddedAvailableBeds() (r int, exists bool) {
	v := m.addavailableBeds
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableBeds resets all changes to the "availableBeds" field.
func (m *BedRecordMutation) ResetAvailableBeds() {
	m.availableBeds = nil
	m.addavailableBeds = nil
}

// SetTotalBeds sets the "totalBeds" field.
func (m *BedRecordMutation) SetTotalBeds(i int) {
	m.totalBeds = &i
	m.addtotalBeds = nil
}

// TotalBeds returns the value of the "totalBeds" field in the mutation.
func (m *BedRecordMutation) TotalBeds() (r int, exists bool) {
	v := m.totalBeds
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalBeds returns the old "totalBeds" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldTotalBeds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalBeds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalBeds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalBeds: %w", err)
	}
	return oldValue.TotalBeds, nil
}

// AddTotalBeds adds i to the "totalBeds" field.
func (m *BedRecordMutation) AddTotalBeds(i int) {
	if m.addtotalBeds != nil {
		*m.addtotalBeds += i
	} else {
		m.addtotalBeds = &i
	}
}

// AddedTotalBeds returns the value that was added to the "totalBeds" field in this mutation.
func (m *BedRecordMutation) AddedTotalBeds() (r int, exists bool) {
	v := m.addtotalBeds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalBeds resets all changes to the "totalBeds" field.
func (m *BedRecordMutation) ResetTotalBeds() {
	m.totalBeds = nil
	m.addtotalBeds = nil
}

// SetKindBed sets the "kindBed" field.
func (m *BedRecordMutation) SetKindBed(s string) {
	m.kindBed = &s
}

// KindBed returns the value of the "kindBed" field in the mutation.
func (m *BedRecordMutation) KindBed() (r string, exists bool) {
	v := m.kindBed
	if v == nil {
		return
	}
	return *v, true
}

// OldKindBed returns the old "kindBed" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldKindBed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKindBed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKindBed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKindBed: %w", err)
	}
	return oldValue.KindBed, nil
}

// ResetKindBed resets all changes to the "kindBed" field.
func (m *BedRecordMutation) ResetKindBed() {
	m.kindBed = nil
}

// SetKindAge sets the "kindAge" field.
func (m *BedRecordMutation) SetKindAge(s string) {
	m.kindAge = &s
}

// KindAge returns the value of the "kindAge" field in the mutation.
func (m *BedRecordMutation) KindAge() (r string, exists bool) {
	v := m.kindAge
	if v == nil {
		return
	}
	return *v, true
}

// OldKindAge returns the old "kindAge" field's value of the BedRecord entity.
// If the BedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BedRecordMutation) OldKindAge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKindAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKindAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKindAge: %w", err)
	}
	return oldValue.KindAge, nil
}

// ResetKindAge resets all changes to the "kindAge" field.
func (m *BedRecordMutation) ResetKindAge() {
	m.kindAge = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *BedRecordMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *BedRecordMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared returns if the "places" edge to the Place entity was cleared.
func (m *BedRecordMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *BedRecordMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *BedRecordMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *BedRecordMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *BedRecordMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Op returns the operation name.
func (m *BedRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BedRecord).
func (m *BedRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BedRecordMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.reportedDate != nil {
		fields = append(fields, bedrecord.FieldReportedDate)
	}
	if m.collectedDate != nil {
		fields = append(fields, bedrecord.FieldCollectedDate)
	}
	if m.busyBeds != nil {
		fields = append(fields, bedrecord.FieldBusyBeds)
	}
	if m.availableBeds != nil {
		fields = append(fields, bedrecord.FieldAvailableBeds)
	}
	if m.totalBeds != nil {
		fields = append(fields, bedrecord.FieldTotalBeds)
	}
	if m.kindBed != nil {
		fields = append(fields, bedrecord.FieldKindBed)
	}
	if m.kindAge != nil {
		fields = append(fields, bedrecord.FieldKindAge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BedRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bedrecord.FieldReportedDate:
		return m.ReportedDate()
	case bedrecord.FieldCollectedDate:
		return m.CollectedDate()
	case bedrecord.FieldBusyBeds:
		return m.BusyBeds()
	case bedrecord.FieldAvailableBeds:
		return m.AvailableBeds()
	case bedrecord.FieldTotalBeds:
		return m.TotalBeds()
	case bedrecord.FieldKindBed:
		return m.KindBed()
	case bedrecord.FieldKindAge:
		return m.KindAge()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BedRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bedrecord.FieldReportedDate:
		return m.OldReportedDate(ctx)
	case bedrecord.FieldCollectedDate:
		return m.OldCollectedDate(ctx)
	case bedrecord.FieldBusyBeds:
		return m.OldBusyBeds(ctx)
	case bedrecord.FieldAvailableBeds:
		return m.OldAvailableBeds(ctx)
	case bedrecord.FieldTotalBeds:
		return m.OldTotalBeds(ctx)
	case bedrecord.FieldKindBed:
		return m.OldKindBed(ctx)
	case bedrecord.FieldKindAge:
		return m.OldKindAge(ctx)
	}
	return nil, fmt.Errorf("unknown BedRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BedRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bedrecord.FieldReportedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedDate(v)
		return nil
	case bedrecord.FieldCollectedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectedDate(v)
		return nil
	case bedrecord.FieldBusyBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusyBeds(v)
		return nil
	case bedrecord.FieldAvailableBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableBeds(v)
		return nil
	case bedrecord.FieldTotalBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalBeds(v)
		return nil
	case bedrecord.FieldKindBed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKindBed(v)
		return nil
	case bedrecord.FieldKindAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKindAge(v)
		return nil
	}
	return fmt.Errorf("unknown BedRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BedRecordMutation) AddedFields() []string {
	var fields []string
	if m.addbusyBeds != nil {
		fields = append(fields, bedrecord.FieldBusyBeds)
	}
	if m.addavailableBeds != nil {
		fields = append(fields, bedrecord.FieldAvailableBeds)
	}
	if m.addtotalBeds != nil {
		fields = append(fields, bedrecord.FieldTotalBeds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BedRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bedrecord.FieldBusyBeds:
		return m.AddedBusyBeds()
	case bedrecord.FieldAvailableBeds:
		return m.AddedAvailableBeds()
	case bedrecord.FieldTotalBeds:
		return m.AddedTotalBeds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BedRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bedrecord.FieldBusyBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusyBeds(v)
		return nil
	case bedrecord.FieldAvailableBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableBeds(v)
		return nil
	case bedrecord.FieldTotalBeds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalBeds(v)
		return nil
	}
	return fmt.Errorf("unknown BedRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BedRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BedRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BedRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BedRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BedRecordMutation) ResetField(name string) error {
	switch name {
	case bedrecord.FieldReportedDate:
		m.ResetReportedDate()
		return nil
	case bedrecord.FieldCollectedDate:
		m.ResetCollectedDate()
		return nil
	case bedrecord.FieldBusyBeds:
		m.ResetBusyBeds()
		return nil
	case bedrecord.FieldAvailableBeds:
		m.ResetAvailableBeds()
		return nil
	case bedrecord.FieldTotalBeds:
		m.ResetTotalBeds()
		return nil
	case bedrecord.FieldKindBed:
		m.ResetKindBed()
		return nil
	case bedrecord.FieldKindAge:
		m.ResetKindAge()
		return nil
	}
	return fmt.Errorf("unknown BedRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BedRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, bedrecord.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BedRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bedrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BedRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, bedrecord.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BedRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bedrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BedRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, bedrecord.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BedRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case bedrecord.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BedRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BedRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BedRecordMutation) ResetEdge(name string) error {
	switch name {
	case bedrecord.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown BedRecord edge %s", name)
}

// DeathRecordMutation represents an operation that mutates the DeathRecord nodes in the graph.
type DeathRecordMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	reportedDate        *time.Time
	collectedDate       *time.Time
	sinadefRegisters    *int
	addsinadefRegisters *int
	minsaRegisters      *int
	addminsaRegisters   *int
	clearedFields       map[string]struct{}
	places              map[int]struct{}
	removedplaces       map[int]struct{}
	clearedplaces       bool
	done                bool
	oldValue            func(context.Context) (*DeathRecord, error)
	predicates          []predicate.DeathRecord
}

var _ ent.Mutation = (*DeathRecordMutation)(nil)

// deathrecordOption allows management of the mutation configuration using functional options.
type deathrecordOption func(*DeathRecordMutation)

// newDeathRecordMutation creates new mutation for the DeathRecord entity.
func newDeathRecordMutation(c config, op Op, opts ...deathrecordOption) *DeathRecordMutation {
	m := &DeathRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeDeathRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeathRecordID sets the ID field of the mutation.
func withDeathRecordID(id int) deathrecordOption {
	return func(m *DeathRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *DeathRecord
		)
		m.oldValue = func(ctx context.Context) (*DeathRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeathRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeathRecord sets the old DeathRecord of the mutation.
func withDeathRecord(node *DeathRecord) deathrecordOption {
	return func(m *DeathRecordMutation) {
		m.oldValue = func(context.Context) (*DeathRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeathRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeathRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DeathRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetReportedDate sets the "reportedDate" field.
func (m *DeathRecordMutation) SetReportedDate(t time.Time) {
	m.reportedDate = &t
}

// ReportedDate returns the value of the "reportedDate" field in the mutation.
func (m *DeathRecordMutation) ReportedDate() (r time.Time, exists bool) {
	v := m.reportedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedDate returns the old "reportedDate" field's value of the DeathRecord entity.
// If the DeathRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathRecordMutation) OldReportedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReportedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReportedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedDate: %w", err)
	}
	return oldValue.ReportedDate, nil
}

// ResetReportedDate resets all changes to the "reportedDate" field.
func (m *DeathRecordMutation) ResetReportedDate() {
	m.reportedDate = nil
}

// SetCollectedDate sets the "collectedDate" field.
func (m *DeathRecordMutation) SetCollectedDate(t time.Time) {
	m.collectedDate = &t
}

// CollectedDate returns the value of the "collectedDate" field in the mutation.
func (m *DeathRecordMutation) CollectedDate() (r time.Time, exists bool) {
	v := m.collectedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectedDate returns the old "collectedDate" field's value of the DeathRecord entity.
// If the DeathRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathRecordMutation) OldCollectedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCollectedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCollectedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectedDate: %w", err)
	}
	return oldValue.CollectedDate, nil
}

// ResetCollectedDate resets all changes to the "collectedDate" field.
func (m *DeathRecordMutation) ResetCollectedDate() {
	m.collectedDate = nil
}

// SetSinadefRegisters sets the "sinadefRegisters" field.
func (m *DeathRecordMutation) SetSinadefRegisters(i int) {
	m.sinadefRegisters = &i
	m.addsinadefRegisters = nil
}

// SinadefRegisters returns the value of the "sinadefRegisters" field in the mutation.
func (m *DeathRecordMutation) SinadefRegisters() (r int, exists bool) {
	v := m.sinadefRegisters
	if v == nil {
		return
	}
	return *v, true
}

// OldSinadefRegisters returns the old "sinadefRegisters" field's value of the DeathRecord entity.
// If the DeathRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathRecordMutation) OldSinadefRegisters(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSinadefRegisters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSinadefRegisters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSinadefRegisters: %w", err)
	}
	return oldValue.SinadefRegisters, nil
}

// AddSinadefRegisters adds i to the "sinadefRegisters" field.
func (m *DeathRecordMutation) AddSinadefRegisters(i int) {
	if m.addsinadefRegisters != nil {
		*m.addsinadefRegisters += i
	} else {
		m.addsinadefRegisters = &i
	}
}

// AddedSinadefRegisters returns the value that was added to the "sinadefRegisters" field in this mutation.
func (m *DeathRecordMutation) AddedSinadefRegisters() (r int, exists bool) {
	v := m.addsinadefRegisters
	if v == nil {
		return
	}
	return *v, true
}

// ResetSinadefRegisters resets all changes to the "sinadefRegisters" field.
func (m *DeathRecordMutation) ResetSinadefRegisters() {
	m.sinadefRegisters = nil
	m.addsinadefRegisters = nil
}

// SetMinsaRegisters sets the "minsaRegisters" field.
func (m *DeathRecordMutation) SetMinsaRegisters(i int) {
	m.minsaRegisters = &i
	m.addminsaRegisters = nil
}

// MinsaRegisters returns the value of the "minsaRegisters" field in the mutation.
func (m *DeathRecordMutation) MinsaRegisters() (r int, exists bool) {
	v := m.minsaRegisters
	if v == nil {
		return
	}
	return *v, true
}

// OldMinsaRegisters returns the old "minsaRegisters" field's value of the DeathRecord entity.
// If the DeathRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathRecordMutation) OldMinsaRegisters(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinsaRegisters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinsaRegisters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinsaRegisters: %w", err)
	}
	return oldValue.MinsaRegisters, nil
}

// AddMinsaRegisters adds i to the "minsaRegisters" field.
func (m *DeathRecordMutation) AddMinsaRegisters(i int) {
	if m.addminsaRegisters != nil {
		*m.addminsaRegisters += i
	} else {
		m.addminsaRegisters = &i
	}
}

// AddedMinsaRegisters returns the value that was added to the "minsaRegisters" field in this mutation.
func (m *DeathRecordMutation) AddedMinsaRegisters() (r int, exists bool) {
	v := m.addminsaRegisters
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinsaRegisters resets all changes to the "minsaRegisters" field.
func (m *DeathRecordMutation) ResetMinsaRegisters() {
	m.minsaRegisters = nil
	m.addminsaRegisters = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *DeathRecordMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *DeathRecordMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared returns if the "places" edge to the Place entity was cleared.
func (m *DeathRecordMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *DeathRecordMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *DeathRecordMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *DeathRecordMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *DeathRecordMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Op returns the operation name.
func (m *DeathRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeathRecord).
func (m *DeathRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeathRecordMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.reportedDate != nil {
		fields = append(fields, deathrecord.FieldReportedDate)
	}
	if m.collectedDate != nil {
		fields = append(fields, deathrecord.FieldCollectedDate)
	}
	if m.sinadefRegisters != nil {
		fields = append(fields, deathrecord.FieldSinadefRegisters)
	}
	if m.minsaRegisters != nil {
		fields = append(fields, deathrecord.FieldMinsaRegisters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeathRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deathrecord.FieldReportedDate:
		return m.ReportedDate()
	case deathrecord.FieldCollectedDate:
		return m.CollectedDate()
	case deathrecord.FieldSinadefRegisters:
		return m.SinadefRegisters()
	case deathrecord.FieldMinsaRegisters:
		return m.MinsaRegisters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeathRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deathrecord.FieldReportedDate:
		return m.OldReportedDate(ctx)
	case deathrecord.FieldCollectedDate:
		return m.OldCollectedDate(ctx)
	case deathrecord.FieldSinadefRegisters:
		return m.OldSinadefRegisters(ctx)
	case deathrecord.FieldMinsaRegisters:
		return m.OldMinsaRegisters(ctx)
	}
	return nil, fmt.Errorf("unknown DeathRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deathrecord.FieldReportedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedDate(v)
		return nil
	case deathrecord.FieldCollectedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectedDate(v)
		return nil
	case deathrecord.FieldSinadefRegisters:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSinadefRegisters(v)
		return nil
	case deathrecord.FieldMinsaRegisters:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinsaRegisters(v)
		return nil
	}
	return fmt.Errorf("unknown DeathRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeathRecordMutation) AddedFields() []string {
	var fields []string
	if m.addsinadefRegisters != nil {
		fields = append(fields, deathrecord.FieldSinadefRegisters)
	}
	if m.addminsaRegisters != nil {
		fields = append(fields, deathrecord.FieldMinsaRegisters)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeathRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deathrecord.FieldSinadefRegisters:
		return m.AddedSinadefRegisters()
	case deathrecord.FieldMinsaRegisters:
		return m.AddedMinsaRegisters()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deathrecord.FieldSinadefRegisters:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSinadefRegisters(v)
		return nil
	case deathrecord.FieldMinsaRegisters:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinsaRegisters(v)
		return nil
	}
	return fmt.Errorf("unknown DeathRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeathRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeathRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeathRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeathRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeathRecordMutation) ResetField(name string) error {
	switch name {
	case deathrecord.FieldReportedDate:
		m.ResetReportedDate()
		return nil
	case deathrecord.FieldCollectedDate:
		m.ResetCollectedDate()
		return nil
	case deathrecord.FieldSinadefRegisters:
		m.ResetSinadefRegisters()
		return nil
	case deathrecord.FieldMinsaRegisters:
		m.ResetMinsaRegisters()
		return nil
	}
	return fmt.Errorf("unknown DeathRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeathRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, deathrecord.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeathRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deathrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeathRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, deathrecord.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeathRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deathrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeathRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, deathrecord.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeathRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case deathrecord.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeathRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeathRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeathRecordMutation) ResetEdge(name string) error {
	switch name {
	case deathrecord.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown DeathRecord edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	places        map[int]struct{}
	removedplaces map[int]struct{}
	clearedplaces bool
	done          bool
	oldValue      func(context.Context) (*District, error)
	predicates    []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id int) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DistrictMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *DistrictMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DistrictMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DistrictMutation) ResetName() {
	m.name = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *DistrictMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *DistrictMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared returns if the "places" edge to the Place entity was cleared.
func (m *DistrictMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *DistrictMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *DistrictMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *DistrictMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *DistrictMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, district.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, district.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, district.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, district.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// InfectedRecordMutation represents an operation that mutates the InfectedRecord nodes in the graph.
type InfectedRecordMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	reportedDate        *time.Time
	collectedDate       *time.Time
	pcrTotalTests       *int
	addpcrTotalTests    *int
	prTotalTests        *int
	addprTotalTests     *int
	agTotalTests        *int
	addagTotalTests     *int
	pcrPositiveTests    *int
	addpcrPositiveTests *int
	prPositiveTests     *int
	addprPositiveTests  *int
	agPositiveTests     *int
	addagPositiveTests  *int
	clearedFields       map[string]struct{}
	places              map[int]struct{}
	removedplaces       map[int]struct{}
	clearedplaces       bool
	done                bool
	oldValue            func(context.Context) (*InfectedRecord, error)
	predicates          []predicate.InfectedRecord
}

var _ ent.Mutation = (*InfectedRecordMutation)(nil)

// infectedrecordOption allows management of the mutation configuration using functional options.
type infectedrecordOption func(*InfectedRecordMutation)

// newInfectedRecordMutation creates new mutation for the InfectedRecord entity.
func newInfectedRecordMutation(c config, op Op, opts ...infectedrecordOption) *InfectedRecordMutation {
	m := &InfectedRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeInfectedRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInfectedRecordID sets the ID field of the mutation.
func withInfectedRecordID(id int) infectedrecordOption {
	return func(m *InfectedRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *InfectedRecord
		)
		m.oldValue = func(ctx context.Context) (*InfectedRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InfectedRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInfectedRecord sets the old InfectedRecord of the mutation.
func withInfectedRecord(node *InfectedRecord) infectedrecordOption {
	return func(m *InfectedRecordMutation) {
		m.oldValue = func(context.Context) (*InfectedRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InfectedRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InfectedRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *InfectedRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetReportedDate sets the "reportedDate" field.
func (m *InfectedRecordMutation) SetReportedDate(t time.Time) {
	m.reportedDate = &t
}

// ReportedDate returns the value of the "reportedDate" field in the mutation.
func (m *InfectedRecordMutation) ReportedDate() (r time.Time, exists bool) {
	v := m.reportedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedDate returns the old "reportedDate" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldReportedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReportedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReportedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedDate: %w", err)
	}
	return oldValue.ReportedDate, nil
}

// ResetReportedDate resets all changes to the "reportedDate" field.
func (m *InfectedRecordMutation) ResetReportedDate() {
	m.reportedDate = nil
}

// SetCollectedDate sets the "collectedDate" field.
func (m *InfectedRecordMutation) SetCollectedDate(t time.Time) {
	m.collectedDate = &t
}

// CollectedDate returns the value of the "collectedDate" field in the mutation.
func (m *InfectedRecordMutation) CollectedDate() (r time.Time, exists bool) {
	v := m.collectedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectedDate returns the old "collectedDate" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldCollectedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCollectedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCollectedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectedDate: %w", err)
	}
	return oldValue.CollectedDate, nil
}

// ResetCollectedDate resets all changes to the "collectedDate" field.
func (m *InfectedRecordMutation) ResetCollectedDate() {
	m.collectedDate = nil
}

// SetPcrTotalTests sets the "pcrTotalTests" field.
func (m *InfectedRecordMutation) SetPcrTotalTests(i int) {
	m.pcrTotalTests = &i
	m.addpcrTotalTests = nil
}

// PcrTotalTests returns the value of the "pcrTotalTests" field in the mutation.
func (m *InfectedRecordMutation) PcrTotalTests() (r int, exists bool) {
	v := m.pcrTotalTests
	if v == nil {
		return
	}
	return *v, true
}

// OldPcrTotalTests returns the old "pcrTotalTests" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldPcrTotalTests(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPcrTotalTests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPcrTotalTests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPcrTotalTests: %w", err)
	}
	return oldValue.PcrTotalTests, nil
}

// AddPcrTotalTests adds i to the "pcrTotalTests" field.
func (m *InfectedRecordMutation) AddPcrTotalTests(i int) {
	if m.addpcrTotalTests != nil {
		*m.addpcrTotalTests += i
	} else {
		m.addpcrTotalTests = &i
	}
}

// AddedPcrTotalTests returns the value that was added to the "pcrTotalTests" field in this mutation.
func (m *InfectedRecordMutation) AddedPcrTotalTests() (r int, exists bool) {
	v := m.addpcrTotalTests
	if v == nil {
		return
	}
	return *v, true
}

// ResetPcrTotalTests resets all changes to the "pcrTotalTests" field.
func (m *InfectedRecordMutation) ResetPcrTotalTests() {
	m.pcrTotalTests = nil
	m.addpcrTotalTests = nil
}

// SetPrTotalTests sets the "prTotalTests" field.
func (m *InfectedRecordMutation) SetPrTotalTests(i int) {
	m.prTotalTests = &i
	m.addprTotalTests = nil
}

// PrTotalTests returns the value of the "prTotalTests" field in the mutation.
func (m *InfectedRecordMutation) PrTotalTests() (r int, exists bool) {
	v := m.prTotalTests
	if v == nil {
		return
	}
	return *v, true
}

// OldPrTotalTests returns the old "prTotalTests" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldPrTotalTests(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrTotalTests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrTotalTests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrTotalTests: %w", err)
	}
	return oldValue.PrTotalTests, nil
}

// AddPrTotalTests adds i to the "prTotalTests" field.
func (m *InfectedRecordMutation) AddPrTotalTests(i int) {
	if m.addprTotalTests != nil {
		*m.addprTotalTests += i
	} else {
		m.addprTotalTests = &i
	}
}

// AddedPrTotalTests returns the value that was added to the "prTotalTests" field in this mutation.
func (m *InfectedRecordMutation) AddedPrTotalTests() (r int, exists bool) {
	v := m.addprTotalTests
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrTotalTests resets all changes to the "prTotalTests" field.
func (m *InfectedRecordMutation) ResetPrTotalTests() {
	m.prTotalTests = nil
	m.addprTotalTests = nil
}

// SetAgTotalTests sets the "agTotalTests" field.
func (m *InfectedRecordMutation) SetAgTotalTests(i int) {
	m.agTotalTests = &i
	m.addagTotalTests = nil
}

// AgTotalTests returns the value of the "agTotalTests" field in the mutation.
func (m *InfectedRecordMutation) AgTotalTests() (r int, exists bool) {
	v := m.agTotalTests
	if v == nil {
		return
	}
	return *v, true
}

// OldAgTotalTests returns the old "agTotalTests" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldAgTotalTests(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgTotalTests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgTotalTests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgTotalTests: %w", err)
	}
	return oldValue.AgTotalTests, nil
}

// AddAgTotalTests adds i to the "agTotalTests" field.
func (m *InfectedRecordMutation) AddAgTotalTests(i int) {
	if m.addagTotalTests != nil {
		*m.addagTotalTests += i
	} else {
		m.addagTotalTests = &i
	}
}

// AddedAgTotalTests returns the value that was added to the "agTotalTests" field in this mutation.
func (m *InfectedRecordMutation) AddedAgTotalTests() (r int, exists bool) {
	v := m.addagTotalTests
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgTotalTests resets all changes to the "agTotalTests" field.
func (m *InfectedRecordMutation) ResetAgTotalTests() {
	m.agTotalTests = nil
	m.addagTotalTests = nil
}

// SetPcrPositiveTests sets the "pcrPositiveTests" field.
func (m *InfectedRecordMutation) SetPcrPositiveTests(i int) {
	m.pcrPositiveTests = &i
	m.addpcrPositiveTests = nil
}

// PcrPositiveTests returns the value of the "pcrPositiveTests" field in the mutation.
func (m *InfectedRecordMutation) PcrPositiveTests() (r int, exists bool) {
	v := m.pcrPositiveTests
	if v == nil {
		return
	}
	return *v, true
}

// OldPcrPositiveTests returns the old "pcrPositiveTests" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldPcrPositiveTests(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPcrPositiveTests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPcrPositiveTests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPcrPositiveTests: %w", err)
	}
	return oldValue.PcrPositiveTests, nil
}

// AddPcrPositiveTests adds i to the "pcrPositiveTests" field.
func (m *InfectedRecordMutation) AddPcrPositiveTests(i int) {
	if m.addpcrPositiveTests != nil {
		*m.addpcrPositiveTests += i
	} else {
		m.addpcrPositiveTests = &i
	}
}

// AddedPcrPositiveTests returns the value that was added to the "pcrPositiveTests" field in this mutation.
func (m *InfectedRecordMutation) AddedPcrPositiveTests() (r int, exists bool) {
	v := m.addpcrPositiveTests
	if v == nil {
		return
	}
	return *v, true
}

// ResetPcrPositiveTests resets all changes to the "pcrPositiveTests" field.
func (m *InfectedRecordMutation) ResetPcrPositiveTests() {
	m.pcrPositiveTests = nil
	m.addpcrPositiveTests = nil
}

// SetPrPositiveTests sets the "prPositiveTests" field.
func (m *InfectedRecordMutation) SetPrPositiveTests(i int) {
	m.prPositiveTests = &i
	m.addprPositiveTests = nil
}

// PrPositiveTests returns the value of the "prPositiveTests" field in the mutation.
func (m *InfectedRecordMutation) PrPositiveTests() (r int, exists bool) {
	v := m.prPositiveTests
	if v == nil {
		return
	}
	return *v, true
}

// OldPrPositiveTests returns the old "prPositiveTests" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldPrPositiveTests(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrPositiveTests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrPositiveTests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrPositiveTests: %w", err)
	}
	return oldValue.PrPositiveTests, nil
}

// AddPrPositiveTests adds i to the "prPositiveTests" field.
func (m *InfectedRecordMutation) AddPrPositiveTests(i int) {
	if m.addprPositiveTests != nil {
		*m.addprPositiveTests += i
	} else {
		m.addprPositiveTests = &i
	}
}

// AddedPrPositiveTests returns the value that was added to the "prPositiveTests" field in this mutation.
func (m *InfectedRecordMutation) AddedPrPositiveTests() (r int, exists bool) {
	v := m.addprPositiveTests
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrPositiveTests resets all changes to the "prPositiveTests" field.
func (m *InfectedRecordMutation) ResetPrPositiveTests() {
	m.prPositiveTests = nil
	m.addprPositiveTests = nil
}

// SetAgPositiveTests sets the "agPositiveTests" field.
func (m *InfectedRecordMutation) SetAgPositiveTests(i int) {
	m.agPositiveTests = &i
	m.addagPositiveTests = nil
}

// AgPositiveTests returns the value of the "agPositiveTests" field in the mutation.
func (m *InfectedRecordMutation) AgPositiveTests() (r int, exists bool) {
	v := m.agPositiveTests
	if v == nil {
		return
	}
	return *v, true
}

// OldAgPositiveTests returns the old "agPositiveTests" field's value of the InfectedRecord entity.
// If the InfectedRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InfectedRecordMutation) OldAgPositiveTests(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgPositiveTests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgPositiveTests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgPositiveTests: %w", err)
	}
	return oldValue.AgPositiveTests, nil
}

// AddAgPositiveTests adds i to the "agPositiveTests" field.
func (m *InfectedRecordMutation) AddAgPositiveTests(i int) {
	if m.addagPositiveTests != nil {
		*m.addagPositiveTests += i
	} else {
		m.addagPositiveTests = &i
	}
}

// AddedAgPositiveTests returns the value that was added to the "agPositiveTests" field in this mutation.
func (m *InfectedRecordMutation) AddedAgPositiveTests() (r int, exists bool) {
	v := m.addagPositiveTests
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgPositiveTests resets all changes to the "agPositiveTests" field.
func (m *InfectedRecordMutation) ResetAgPositiveTests() {
	m.agPositiveTests = nil
	m.addagPositiveTests = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *InfectedRecordMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *InfectedRecordMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared returns if the "places" edge to the Place entity was cleared.
func (m *InfectedRecordMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *InfectedRecordMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *InfectedRecordMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *InfectedRecordMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *InfectedRecordMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Op returns the operation name.
func (m *InfectedRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InfectedRecord).
func (m *InfectedRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InfectedRecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.reportedDate != nil {
		fields = append(fields, infectedrecord.FieldReportedDate)
	}
	if m.collectedDate != nil {
		fields = append(fields, infectedrecord.FieldCollectedDate)
	}
	if m.pcrTotalTests != nil {
		fields = append(fields, infectedrecord.FieldPcrTotalTests)
	}
	if m.prTotalTests != nil {
		fields = append(fields, infectedrecord.FieldPrTotalTests)
	}
	if m.agTotalTests != nil {
		fields = append(fields, infectedrecord.FieldAgTotalTests)
	}
	if m.pcrPositiveTests != nil {
		fields = append(fields, infectedrecord.FieldPcrPositiveTests)
	}
	if m.prPositiveTests != nil {
		fields = append(fields, infectedrecord.FieldPrPositiveTests)
	}
	if m.agPositiveTests != nil {
		fields = append(fields, infectedrecord.FieldAgPositiveTests)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InfectedRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case infectedrecord.FieldReportedDate:
		return m.ReportedDate()
	case infectedrecord.FieldCollectedDate:
		return m.CollectedDate()
	case infectedrecord.FieldPcrTotalTests:
		return m.PcrTotalTests()
	case infectedrecord.FieldPrTotalTests:
		return m.PrTotalTests()
	case infectedrecord.FieldAgTotalTests:
		return m.AgTotalTests()
	case infectedrecord.FieldPcrPositiveTests:
		return m.PcrPositiveTests()
	case infectedrecord.FieldPrPositiveTests:
		return m.PrPositiveTests()
	case infectedrecord.FieldAgPositiveTests:
		return m.AgPositiveTests()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InfectedRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case infectedrecord.FieldReportedDate:
		return m.OldReportedDate(ctx)
	case infectedrecord.FieldCollectedDate:
		return m.OldCollectedDate(ctx)
	case infectedrecord.FieldPcrTotalTests:
		return m.OldPcrTotalTests(ctx)
	case infectedrecord.FieldPrTotalTests:
		return m.OldPrTotalTests(ctx)
	case infectedrecord.FieldAgTotalTests:
		return m.OldAgTotalTests(ctx)
	case infectedrecord.FieldPcrPositiveTests:
		return m.OldPcrPositiveTests(ctx)
	case infectedrecord.FieldPrPositiveTests:
		return m.OldPrPositiveTests(ctx)
	case infectedrecord.FieldAgPositiveTests:
		return m.OldAgPositiveTests(ctx)
	}
	return nil, fmt.Errorf("unknown InfectedRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InfectedRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case infectedrecord.FieldReportedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedDate(v)
		return nil
	case infectedrecord.FieldCollectedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectedDate(v)
		return nil
	case infectedrecord.FieldPcrTotalTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPcrTotalTests(v)
		return nil
	case infectedrecord.FieldPrTotalTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrTotalTests(v)
		return nil
	case infectedrecord.FieldAgTotalTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgTotalTests(v)
		return nil
	case infectedrecord.FieldPcrPositiveTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPcrPositiveTests(v)
		return nil
	case infectedrecord.FieldPrPositiveTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrPositiveTests(v)
		return nil
	case infectedrecord.FieldAgPositiveTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgPositiveTests(v)
		return nil
	}
	return fmt.Errorf("unknown InfectedRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InfectedRecordMutation) AddedFields() []string {
	var fields []string
	if m.addpcrTotalTests != nil {
		fields = append(fields, infectedrecord.FieldPcrTotalTests)
	}
	if m.addprTotalTests != nil {
		fields = append(fields, infectedrecord.FieldPrTotalTests)
	}
	if m.addagTotalTests != nil {
		fields = append(fields, infectedrecord.FieldAgTotalTests)
	}
	if m.addpcrPositiveTests != nil {
		fields = append(fields, infectedrecord.FieldPcrPositiveTests)
	}
	if m.addprPositiveTests != nil {
		fields = append(fields, infectedrecord.FieldPrPositiveTests)
	}
	if m.addagPositiveTests != nil {
		fields = append(fields, infectedrecord.FieldAgPositiveTests)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InfectedRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case infectedrecord.FieldPcrTotalTests:
		return m.AddedPcrTotalTests()
	case infectedrecord.FieldPrTotalTests:
		return m.AddedPrTotalTests()
	case infectedrecord.FieldAgTotalTests:
		return m.AddedAgTotalTests()
	case infectedrecord.FieldPcrPositiveTests:
		return m.AddedPcrPositiveTests()
	case infectedrecord.FieldPrPositiveTests:
		return m.AddedPrPositiveTests()
	case infectedrecord.FieldAgPositiveTests:
		return m.AddedAgPositiveTests()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InfectedRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case infectedrecord.FieldPcrTotalTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPcrTotalTests(v)
		return nil
	case infectedrecord.FieldPrTotalTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrTotalTests(v)
		return nil
	case infectedrecord.FieldAgTotalTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgTotalTests(v)
		return nil
	case infectedrecord.FieldPcrPositiveTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPcrPositiveTests(v)
		return nil
	case infectedrecord.FieldPrPositiveTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrPositiveTests(v)
		return nil
	case infectedrecord.FieldAgPositiveTests:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgPositiveTests(v)
		return nil
	}
	return fmt.Errorf("unknown InfectedRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InfectedRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InfectedRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InfectedRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InfectedRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InfectedRecordMutation) ResetField(name string) error {
	switch name {
	case infectedrecord.FieldReportedDate:
		m.ResetReportedDate()
		return nil
	case infectedrecord.FieldCollectedDate:
		m.ResetCollectedDate()
		return nil
	case infectedrecord.FieldPcrTotalTests:
		m.ResetPcrTotalTests()
		return nil
	case infectedrecord.FieldPrTotalTests:
		m.ResetPrTotalTests()
		return nil
	case infectedrecord.FieldAgTotalTests:
		m.ResetAgTotalTests()
		return nil
	case infectedrecord.FieldPcrPositiveTests:
		m.ResetPcrPositiveTests()
		return nil
	case infectedrecord.FieldPrPositiveTests:
		m.ResetPrPositiveTests()
		return nil
	case infectedrecord.FieldAgPositiveTests:
		m.ResetAgPositiveTests()
		return nil
	}
	return fmt.Errorf("unknown InfectedRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InfectedRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, infectedrecord.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InfectedRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case infectedrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InfectedRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, infectedrecord.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InfectedRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case infectedrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InfectedRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, infectedrecord.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InfectedRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case infectedrecord.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InfectedRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InfectedRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InfectedRecordMutation) ResetEdge(name string) error {
	switch name {
	case infectedrecord.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown InfectedRecord edge %s", name)
}

// OccurencyMutation represents an operation that mutates the Occurency nodes in the graph.
type OccurencyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *string
	reportedRecord  *time.Time
	resultDate      *time.Time
	biologicalSex   *string
	age             *int
	addage          *int
	clearedFields   map[string]struct{}
	region          *int
	clearedregion   bool
	province        *int
	clearedprovince bool
	district        *int
	cleareddistrict bool
	done            bool
	oldValue        func(context.Context) (*Occurency, error)
	predicates      []predicate.Occurency
}

var _ ent.Mutation = (*OccurencyMutation)(nil)

// occurencyOption allows management of the mutation configuration using functional options.
type occurencyOption func(*OccurencyMutation)

// newOccurencyMutation creates new mutation for the Occurency entity.
func newOccurencyMutation(c config, op Op, opts ...occurencyOption) *OccurencyMutation {
	m := &OccurencyMutation{
		config:        c,
		op:            op,
		typ:           TypeOccurency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccurencyID sets the ID field of the mutation.
func withOccurencyID(id int) occurencyOption {
	return func(m *OccurencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Occurency
		)
		m.oldValue = func(ctx context.Context) (*Occurency, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occurency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccurency sets the old Occurency of the mutation.
func withOccurency(node *Occurency) occurencyOption {
	return func(m *OccurencyMutation) {
		m.oldValue = func(context.Context) (*Occurency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccurencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccurencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OccurencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *OccurencyMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *OccurencyMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Occurency entity.
// If the Occurency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurencyMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *OccurencyMutation) ResetUUID() {
	m.uuid = nil
}

// SetReportedRecord sets the "reportedRecord" field.
func (m *OccurencyMutation) SetReportedRecord(t time.Time) {
	m.reportedRecord = &t
}

// ReportedRecord returns the value of the "reportedRecord" field in the mutation.
func (m *OccurencyMutation) ReportedRecord() (r time.Time, exists bool) {
	v := m.reportedRecord
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedRecord returns the old "reportedRecord" field's value of the Occurency entity.
// If the Occurency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurencyMutation) OldReportedRecord(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReportedRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReportedRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedRecord: %w", err)
	}
	return oldValue.ReportedRecord, nil
}

// ResetReportedRecord resets all changes to the "reportedRecord" field.
func (m *OccurencyMutation) ResetReportedRecord() {
	m.reportedRecord = nil
}

// SetResultDate sets the "resultDate" field.
func (m *OccurencyMutation) SetResultDate(t time.Time) {
	m.resultDate = &t
}

// ResultDate returns the value of the "resultDate" field in the mutation.
func (m *OccurencyMutation) ResultDate() (r time.Time, exists bool) {
	v := m.resultDate
	if v == nil {
		return
	}
	return *v, true
}

// OldResultDate returns the old "resultDate" field's value of the Occurency entity.
// If the Occurency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurencyMutation) OldResultDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResultDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResultDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultDate: %w", err)
	}
	return oldValue.ResultDate, nil
}

// ResetResultDate resets all changes to the "resultDate" field.
func (m *OccurencyMutation) ResetResultDate() {
	m.resultDate = nil
}

// SetBiologicalSex sets the "biologicalSex" field.
func (m *OccurencyMutation) SetBiologicalSex(s string) {
	m.biologicalSex = &s
}

// BiologicalSex returns the value of the "biologicalSex" field in the mutation.
func (m *OccurencyMutation) BiologicalSex() (r string, exists bool) {
	v := m.biologicalSex
	if v == nil {
		return
	}
	return *v, true
}

// OldBiologicalSex returns the old "biologicalSex" field's value of the Occurency entity.
// If the Occurency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurencyMutation) OldBiologicalSex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBiologicalSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBiologicalSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiologicalSex: %w", err)
	}
	return oldValue.BiologicalSex, nil
}

// ResetBiologicalSex resets all changes to the "biologicalSex" field.
func (m *OccurencyMutation) ResetBiologicalSex() {
	m.biologicalSex = nil
}

// SetAge sets the "age" field.
func (m *OccurencyMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *OccurencyMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Occurency entity.
// If the Occurency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurencyMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *OccurencyMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *OccurencyMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *OccurencyMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *OccurencyMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *OccurencyMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared returns if the "region" edge to the Region entity was cleared.
func (m *OccurencyMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *OccurencyMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *OccurencyMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *OccurencyMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// SetProvinceID sets the "province" edge to the Province entity by id.
func (m *OccurencyMutation) SetProvinceID(id int) {
	m.province = &id
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *OccurencyMutation) ClearProvince() {
	m.clearedprovince = true
}

// ProvinceCleared returns if the "province" edge to the Province entity was cleared.
func (m *OccurencyMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceID returns the "province" edge ID in the mutation.
func (m *OccurencyMutation) ProvinceID() (id int, exists bool) {
	if m.province != nil {
		return *m.province, true
	}
	return
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *OccurencyMutation) ProvinceIDs() (ids []int) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *OccurencyMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *OccurencyMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *OccurencyMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared returns if the "district" edge to the District entity was cleared.
func (m *OccurencyMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *OccurencyMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *OccurencyMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *OccurencyMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// Op returns the operation name.
func (m *OccurencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Occurency).
func (m *OccurencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccurencyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uuid != nil {
		fields = append(fields, occurency.FieldUUID)
	}
	if m.reportedRecord != nil {
		fields = append(fields, occurency.FieldReportedRecord)
	}
	if m.resultDate != nil {
		fields = append(fields, occurency.FieldResultDate)
	}
	if m.biologicalSex != nil {
		fields = append(fields, occurency.FieldBiologicalSex)
	}
	if m.age != nil {
		fields = append(fields, occurency.FieldAge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccurencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occurency.FieldUUID:
		return m.UUID()
	case occurency.FieldReportedRecord:
		return m.ReportedRecord()
	case occurency.FieldResultDate:
		return m.ResultDate()
	case occurency.FieldBiologicalSex:
		return m.BiologicalSex()
	case occurency.FieldAge:
		return m.Age()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccurencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occurency.FieldUUID:
		return m.OldUUID(ctx)
	case occurency.FieldReportedRecord:
		return m.OldReportedRecord(ctx)
	case occurency.FieldResultDate:
		return m.OldResultDate(ctx)
	case occurency.FieldBiologicalSex:
		return m.OldBiologicalSex(ctx)
	case occurency.FieldAge:
		return m.OldAge(ctx)
	}
	return nil, fmt.Errorf("unknown Occurency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occurency.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case occurency.FieldReportedRecord:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedRecord(v)
		return nil
	case occurency.FieldResultDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultDate(v)
		return nil
	case occurency.FieldBiologicalSex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiologicalSex(v)
		return nil
	case occurency.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	}
	return fmt.Errorf("unknown Occurency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccurencyMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, occurency.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccurencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case occurency.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case occurency.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Occurency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccurencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccurencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccurencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Occurency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccurencyMutation) ResetField(name string) error {
	switch name {
	case occurency.FieldUUID:
		m.ResetUUID()
		return nil
	case occurency.FieldReportedRecord:
		m.ResetReportedRecord()
		return nil
	case occurency.FieldResultDate:
		m.ResetResultDate()
		return nil
	case occurency.FieldBiologicalSex:
		m.ResetBiologicalSex()
		return nil
	case occurency.FieldAge:
		m.ResetAge()
		return nil
	}
	return fmt.Errorf("unknown Occurency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccurencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.region != nil {
		edges = append(edges, occurency.EdgeRegion)
	}
	if m.province != nil {
		edges = append(edges, occurency.EdgeProvince)
	}
	if m.district != nil {
		edges = append(edges, occurency.EdgeDistrict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccurencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occurency.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	case occurency.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case occurency.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccurencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccurencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccurencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedregion {
		edges = append(edges, occurency.EdgeRegion)
	}
	if m.clearedprovince {
		edges = append(edges, occurency.EdgeProvince)
	}
	if m.cleareddistrict {
		edges = append(edges, occurency.EdgeDistrict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccurencyMutation) EdgeCleared(name string) bool {
	switch name {
	case occurency.EdgeRegion:
		return m.clearedregion
	case occurency.EdgeProvince:
		return m.clearedprovince
	case occurency.EdgeDistrict:
		return m.cleareddistrict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccurencyMutation) ClearEdge(name string) error {
	switch name {
	case occurency.EdgeRegion:
		m.ClearRegion()
		return nil
	case occurency.EdgeProvince:
		m.ClearProvince()
		return nil
	case occurency.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Occurency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccurencyMutation) ResetEdge(name string) error {
	switch name {
	case occurency.EdgeRegion:
		m.ResetRegion()
		return nil
	case occurency.EdgeProvince:
		m.ResetProvince()
		return nil
	case occurency.EdgeDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown Occurency edge %s", name)
}

// OxygenRecordMutation represents an operation that mutates the OxygenRecord nodes in the graph.
type OxygenRecordMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	reportedDate          *time.Time
	collectedDate         *time.Time
	totalCylinders        *int
	addtotalCylinders     *int
	totalOwnCylinders     *int
	addtotalOwnCylinders  *int
	dailyProduction       *int
	adddailyProduction    *int
	maxDailyProduction    *int
	addmaxDailyProduction *int
	dailyConsumption      *int
	adddailyConsumption   *int
	mainSourceKind        *string
	clearedFields         map[string]struct{}
	places                map[int]struct{}
	removedplaces         map[int]struct{}
	clearedplaces         bool
	done                  bool
	oldValue              func(context.Context) (*OxygenRecord, error)
	predicates            []predicate.OxygenRecord
}

var _ ent.Mutation = (*OxygenRecordMutation)(nil)

// oxygenrecordOption allows management of the mutation configuration using functional options.
type oxygenrecordOption func(*OxygenRecordMutation)

// newOxygenRecordMutation creates new mutation for the OxygenRecord entity.
func newOxygenRecordMutation(c config, op Op, opts ...oxygenrecordOption) *OxygenRecordMutation {
	m := &OxygenRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeOxygenRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOxygenRecordID sets the ID field of the mutation.
func withOxygenRecordID(id int) oxygenrecordOption {
	return func(m *OxygenRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *OxygenRecord
		)
		m.oldValue = func(ctx context.Context) (*OxygenRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OxygenRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOxygenRecord sets the old OxygenRecord of the mutation.
func withOxygenRecord(node *OxygenRecord) oxygenrecordOption {
	return func(m *OxygenRecordMutation) {
		m.oldValue = func(context.Context) (*OxygenRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OxygenRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OxygenRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OxygenRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetReportedDate sets the "reportedDate" field.
func (m *OxygenRecordMutation) SetReportedDate(t time.Time) {
	m.reportedDate = &t
}

// ReportedDate returns the value of the "reportedDate" field in the mutation.
func (m *OxygenRecordMutation) ReportedDate() (r time.Time, exists bool) {
	v := m.reportedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedDate returns the old "reportedDate" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldReportedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReportedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReportedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedDate: %w", err)
	}
	return oldValue.ReportedDate, nil
}

// ResetReportedDate resets all changes to the "reportedDate" field.
func (m *OxygenRecordMutation) ResetReportedDate() {
	m.reportedDate = nil
}

// SetCollectedDate sets the "collectedDate" field.
func (m *OxygenRecordMutation) SetCollectedDate(t time.Time) {
	m.collectedDate = &t
}

// CollectedDate returns the value of the "collectedDate" field in the mutation.
func (m *OxygenRecordMutation) CollectedDate() (r time.Time, exists bool) {
	v := m.collectedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectedDate returns the old "collectedDate" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldCollectedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCollectedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCollectedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectedDate: %w", err)
	}
	return oldValue.CollectedDate, nil
}

// ResetCollectedDate resets all changes to the "collectedDate" field.
func (m *OxygenRecordMutation) ResetCollectedDate() {
	m.collectedDate = nil
}

// SetTotalCylinders sets the "totalCylinders" field.
func (m *OxygenRecordMutation) SetTotalCylinders(i int) {
	m.totalCylinders = &i
	m.addtotalCylinders = nil
}

// TotalCylinders returns the value of the "totalCylinders" field in the mutation.
func (m *OxygenRecordMutation) TotalCylinders() (r int, exists bool) {
	v := m.totalCylinders
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCylinders returns the old "totalCylinders" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldTotalCylinders(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalCylinders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalCylinders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCylinders: %w", err)
	}
	return oldValue.TotalCylinders, nil
}

// AddTotalCylinders adds i to the "totalCylinders" field.
func (m *OxygenRecordMutation) AddTotalCylinders(i int) {
	if m.addtotalCylinders != nil {
		*m.addtotalCylinders += i
	} else {
		m.addtotalCylinders = &i
	}
}

// AddedTotalCylinders returns the value that was added to the "totalCylinders" field in this mutation.
func (m *OxygenRecordMutation) AddedTotalCylinders() (r int, exists bool) {
	v := m.addtotalCylinders
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCylinders resets all changes to the "totalCylinders" field.
func (m *OxygenRecordMutation) ResetTotalCylinders() {
	m.totalCylinders = nil
	m.addtotalCylinders = nil
}

// SetTotalOwnCylinders sets the "totalOwnCylinders" field.
func (m *OxygenRecordMutation) SetTotalOwnCylinders(i int) {
	m.totalOwnCylinders = &i
	m.addtotalOwnCylinders = nil
}

// TotalOwnCylinders returns the value of the "totalOwnCylinders" field in the mutation.
func (m *OxygenRecordMutation) TotalOwnCylinders() (r int, exists bool) {
	v := m.totalOwnCylinders
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalOwnCylinders returns the old "totalOwnCylinders" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldTotalOwnCylinders(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalOwnCylinders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalOwnCylinders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalOwnCylinders: %w", err)
	}
	return oldValue.TotalOwnCylinders, nil
}

// AddTotalOwnCylinders adds i to the "totalOwnCylinders" field.
func (m *OxygenRecordMutation) AddTotalOwnCylinders(i int) {
	if m.addtotalOwnCylinders != nil {
		*m.addtotalOwnCylinders += i
	} else {
		m.addtotalOwnCylinders = &i
	}
}

// AddedTotalOwnCylinders returns the value that was added to the "totalOwnCylinders" field in this mutation.
func (m *OxygenRecordMutation) AddedTotalOwnCylinders() (r int, exists bool) {
	v := m.addtotalOwnCylinders
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalOwnCylinders resets all changes to the "totalOwnCylinders" field.
func (m *OxygenRecordMutation) ResetTotalOwnCylinders() {
	m.totalOwnCylinders = nil
	m.addtotalOwnCylinders = nil
}

// SetDailyProduction sets the "dailyProduction" field.
func (m *OxygenRecordMutation) SetDailyProduction(i int) {
	m.dailyProduction = &i
	m.adddailyProduction = nil
}

// DailyProduction returns the value of the "dailyProduction" field in the mutation.
func (m *OxygenRecordMutation) DailyProduction() (r int, exists bool) {
	v := m.dailyProduction
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyProduction returns the old "dailyProduction" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldDailyProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyProduction: %w", err)
	}
	return oldValue.DailyProduction, nil
}

// AddDailyProduction adds i to the "dailyProduction" field.
func (m *OxygenRecordMutation) AddDailyProduction(i int) {
	if m.adddailyProduction != nil {
		*m.adddailyProduction += i
	} else {
		m.adddailyProduction = &i
	}
}

// AddedDailyProduction returns the value that was added to the "dailyProduction" field in this mutation.
func (m *OxygenRecordMutation) AddedDailyProduction() (r int, exists bool) {
	v := m.adddailyProduction
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyProduction resets all changes to the "dailyProduction" field.
func (m *OxygenRecordMutation) ResetDailyProduction() {
	m.dailyProduction = nil
	m.adddailyProduction = nil
}

// SetMaxDailyProduction sets the "maxDailyProduction" field.
func (m *OxygenRecordMutation) SetMaxDailyProduction(i int) {
	m.maxDailyProduction = &i
	m.addmaxDailyProduction = nil
}

// MaxDailyProduction returns the value of the "maxDailyProduction" field in the mutation.
func (m *OxygenRecordMutation) MaxDailyProduction() (r int, exists bool) {
	v := m.maxDailyProduction
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDailyProduction returns the old "maxDailyProduction" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldMaxDailyProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxDailyProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxDailyProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDailyProduction: %w", err)
	}
	return oldValue.MaxDailyProduction, nil
}

// AddMaxDailyProduction adds i to the "maxDailyProduction" field.
func (m *OxygenRecordMutation) AddMaxDailyProduction(i int) {
	if m.addmaxDailyProduction != nil {
		*m.addmaxDailyProduction += i
	} else {
		m.addmaxDailyProduction = &i
	}
}

// AddedMaxDailyProduction returns the value that was added to the "maxDailyProduction" field in this mutation.
func (m *OxygenRecordMutation) AddedMaxDailyProduction() (r int, exists bool) {
	v := m.addmaxDailyProduction
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDailyProduction resets all changes to the "maxDailyProduction" field.
func (m *OxygenRecordMutation) ResetMaxDailyProduction() {
	m.maxDailyProduction = nil
	m.addmaxDailyProduction = nil
}

// SetDailyConsumption sets the "dailyConsumption" field.
func (m *OxygenRecordMutation) SetDailyConsumption(i int) {
	m.dailyConsumption = &i
	m.adddailyConsumption = nil
}

// DailyConsumption returns the value of the "dailyConsumption" field in the mutation.
func (m *OxygenRecordMutation) DailyConsumption() (r int, exists bool) {
	v := m.dailyConsumption
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyConsumption returns the old "dailyConsumption" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldDailyConsumption(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyConsumption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyConsumption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyConsumption: %w", err)
	}
	return oldValue.DailyConsumption, nil
}

// AddDailyConsumption adds i to the "dailyConsumption" field.
func (m *OxygenRecordMutation) AddDailyConsumption(i int) {
	if m.adddailyConsumption != nil {
		*m.adddailyConsumption += i
	} else {
		m.adddailyConsumption = &i
	}
}

// AddedDailyConsumption returns the value that was added to the "dailyConsumption" field in this mutation.
func (m *OxygenRecordMutation) AddedDailyConsumption() (r int, exists bool) {
	v := m.adddailyConsumption
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyConsumption resets all changes to the "dailyConsumption" field.
func (m *OxygenRecordMutation) ResetDailyConsumption() {
	m.dailyConsumption = nil
	m.adddailyConsumption = nil
}

// SetMainSourceKind sets the "mainSourceKind" field.
func (m *OxygenRecordMutation) SetMainSourceKind(s string) {
	m.mainSourceKind = &s
}

// MainSourceKind returns the value of the "mainSourceKind" field in the mutation.
func (m *OxygenRecordMutation) MainSourceKind() (r string, exists bool) {
	v := m.mainSourceKind
	if v == nil {
		return
	}
	return *v, true
}

// OldMainSourceKind returns the old "mainSourceKind" field's value of the OxygenRecord entity.
// If the OxygenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OxygenRecordMutation) OldMainSourceKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMainSourceKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMainSourceKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainSourceKind: %w", err)
	}
	return oldValue.MainSourceKind, nil
}

// ResetMainSourceKind resets all changes to the "mainSourceKind" field.
func (m *OxygenRecordMutation) ResetMainSourceKind() {
	m.mainSourceKind = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *OxygenRecordMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *OxygenRecordMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared returns if the "places" edge to the Place entity was cleared.
func (m *OxygenRecordMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *OxygenRecordMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *OxygenRecordMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *OxygenRecordMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *OxygenRecordMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Op returns the operation name.
func (m *OxygenRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OxygenRecord).
func (m *OxygenRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OxygenRecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.reportedDate != nil {
		fields = append(fields, oxygenrecord.FieldReportedDate)
	}
	if m.collectedDate != nil {
		fields = append(fields, oxygenrecord.FieldCollectedDate)
	}
	if m.totalCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalCylinders)
	}
	if m.totalOwnCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalOwnCylinders)
	}
	if m.dailyProduction != nil {
		fields = append(fields, oxygenrecord.FieldDailyProduction)
	}
	if m.maxDailyProduction != nil {
		fields = append(fields, oxygenrecord.FieldMaxDailyProduction)
	}
	if m.dailyConsumption != nil {
		fields = append(fields, oxygenrecord.FieldDailyConsumption)
	}
	if m.mainSourceKind != nil {
		fields = append(fields, oxygenrecord.FieldMainSourceKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OxygenRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oxygenrecord.FieldReportedDate:
		return m.ReportedDate()
	case oxygenrecord.FieldCollectedDate:
		return m.CollectedDate()
	case oxygenrecord.FieldTotalCylinders:
		return m.TotalCylinders()
	case oxygenrecord.FieldTotalOwnCylinders:
		return m.TotalOwnCylinders()
	case oxygenrecord.FieldDailyProduction:
		return m.DailyProduction()
	case oxygenrecord.FieldMaxDailyProduction:
		return m.MaxDailyProduction()
	case oxygenrecord.FieldDailyConsumption:
		return m.DailyConsumption()
	case oxygenrecord.FieldMainSourceKind:
		return m.MainSourceKind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OxygenRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oxygenrecord.FieldReportedDate:
		return m.OldReportedDate(ctx)
	case oxygenrecord.FieldCollectedDate:
		return m.OldCollectedDate(ctx)
	case oxygenrecord.FieldTotalCylinders:
		return m.OldTotalCylinders(ctx)
	case oxygenrecord.FieldTotalOwnCylinders:
		return m.OldTotalOwnCylinders(ctx)
	case oxygenrecord.FieldDailyProduction:
		return m.OldDailyProduction(ctx)
	case oxygenrecord.FieldMaxDailyProduction:
		return m.OldMaxDailyProduction(ctx)
	case oxygenrecord.FieldDailyConsumption:
		return m.OldDailyConsumption(ctx)
	case oxygenrecord.FieldMainSourceKind:
		return m.OldMainSourceKind(ctx)
	}
	return nil, fmt.Errorf("unknown OxygenRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OxygenRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oxygenrecord.FieldReportedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedDate(v)
		return nil
	case oxygenrecord.FieldCollectedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectedDate(v)
		return nil
	case oxygenrecord.FieldTotalCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCylinders(v)
		return nil
	case oxygenrecord.FieldTotalOwnCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalOwnCylinders(v)
		return nil
	case oxygenrecord.FieldDailyProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyProduction(v)
		return nil
	case oxygenrecord.FieldMaxDailyProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDailyProduction(v)
		return nil
	case oxygenrecord.FieldDailyConsumption:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyConsumption(v)
		return nil
	case oxygenrecord.FieldMainSourceKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainSourceKind(v)
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OxygenRecordMutation) AddedFields() []string {
	var fields []string
	if m.addtotalCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalCylinders)
	}
	if m.addtotalOwnCylinders != nil {
		fields = append(fields, oxygenrecord.FieldTotalOwnCylinders)
	}
	if m.adddailyProduction != nil {
		fields = append(fields, oxygenrecord.FieldDailyProduction)
	}
	if m.addmaxDailyProduction != nil {
		fields = append(fields, oxygenrecord.FieldMaxDailyProduction)
	}
	if m.adddailyConsumption != nil {
		fields = append(fields, oxygenrecord.FieldDailyConsumption)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OxygenRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		return m.AddedTotalCylinders()
	case oxygenrecord.FieldTotalOwnCylinders:
		return m.AddedTotalOwnCylinders()
	case oxygenrecord.FieldDailyProduction:
		return m.AddedDailyProduction()
	case oxygenrecord.FieldMaxDailyProduction:
		return m.AddedMaxDailyProduction()
	case oxygenrecord.FieldDailyConsumption:
		return m.AddedDailyConsumption()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OxygenRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oxygenrecord.FieldTotalCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCylinders(v)
		return nil
	case oxygenrecord.FieldTotalOwnCylinders:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalOwnCylinders(v)
		return nil
	case oxygenrecord.FieldDailyProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyProduction(v)
		return nil
	case oxygenrecord.FieldMaxDailyProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDailyProduction(v)
		return nil
	case oxygenrecord.FieldDailyConsumption:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyConsumption(v)
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OxygenRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OxygenRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OxygenRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OxygenRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OxygenRecordMutation) ResetField(name string) error {
	switch name {
	case oxygenrecord.FieldReportedDate:
		m.ResetReportedDate()
		return nil
	case oxygenrecord.FieldCollectedDate:
		m.ResetCollectedDate()
		return nil
	case oxygenrecord.FieldTotalCylinders:
		m.ResetTotalCylinders()
		return nil
	case oxygenrecord.FieldTotalOwnCylinders:
		m.ResetTotalOwnCylinders()
		return nil
	case oxygenrecord.FieldDailyProduction:
		m.ResetDailyProduction()
		return nil
	case oxygenrecord.FieldMaxDailyProduction:
		m.ResetMaxDailyProduction()
		return nil
	case oxygenrecord.FieldDailyConsumption:
		m.ResetDailyConsumption()
		return nil
	case oxygenrecord.FieldMainSourceKind:
		m.ResetMainSourceKind()
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OxygenRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, oxygenrecord.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OxygenRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oxygenrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OxygenRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, oxygenrecord.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OxygenRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oxygenrecord.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OxygenRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, oxygenrecord.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OxygenRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case oxygenrecord.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OxygenRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OxygenRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OxygenRecordMutation) ResetEdge(name string) error {
	switch name {
	case oxygenrecord.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown OxygenRecord edge %s", name)
}

// PlaceMutation represents an operation that mutates the Place nodes in the graph.
type PlaceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	kind                   *string
	name                   *string
	politic                *string
	ubigeo                 *string
	covidZone              *bool
	lat                    *float64
	addlat                 *float64
	lon                    *float64
	addlon                 *float64
	clearedFields          map[string]struct{}
	oxygenrecords          map[int]struct{}
	removedoxygenrecords   map[int]struct{}
	clearedoxygenrecords   bool
	bedRecords             map[int]struct{}
	removedbedRecords      map[int]struct{}
	clearedbedRecords      bool
	deathRecords           map[int]struct{}
	removeddeathRecords    map[int]struct{}
	cleareddeathRecords    bool
	infectedRecords        map[int]struct{}
	removedinfectedRecords map[int]struct{}
	clearedinfectedRecords bool
	region                 *int
	clearedregion          bool
	province               *int
	clearedprovince        bool
	district               *int
	cleareddistrict        bool
	done                   bool
	oldValue               func(context.Context) (*Place, error)
	predicates             []predicate.Place
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows management of the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for the Place entity.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the ID field of the mutation.
func withPlaceID(id int) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PlaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetKind sets the "kind" field.
func (m *PlaceMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *PlaceMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *PlaceMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *PlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaceMutation) ResetName() {
	m.name = nil
}

// SetPolitic sets the "politic" field.
func (m *PlaceMutation) SetPolitic(s string) {
	m.politic = &s
}

// Politic returns the value of the "politic" field in the mutation.
func (m *PlaceMutation) Politic() (r string, exists bool) {
	v := m.politic
	if v == nil {
		return
	}
	return *v, true
}

// OldPolitic returns the old "politic" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPolitic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPolitic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPolitic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolitic: %w", err)
	}
	return oldValue.Politic, nil
}

// ClearPolitic clears the value of the "politic" field.
func (m *PlaceMutation) ClearPolitic() {
	m.politic = nil
	m.clearedFields[place.FieldPolitic] = struct{}{}
}

// PoliticCleared returns if the "politic" field was cleared in this mutation.
func (m *PlaceMutation) PoliticCleared() bool {
	_, ok := m.clearedFields[place.FieldPolitic]
	return ok
}

// ResetPolitic resets all changes to the "politic" field.
func (m *PlaceMutation) ResetPolitic() {
	m.politic = nil
	delete(m.clearedFields, place.FieldPolitic)
}

// SetUbigeo sets the "ubigeo" field.
func (m *PlaceMutation) SetUbigeo(s string) {
	m.ubigeo = &s
}

// Ubigeo returns the value of the "ubigeo" field in the mutation.
func (m *PlaceMutation) Ubigeo() (r string, exists bool) {
	v := m.ubigeo
	if v == nil {
		return
	}
	return *v, true
}

// OldUbigeo returns the old "ubigeo" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldUbigeo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUbigeo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUbigeo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUbigeo: %w", err)
	}
	return oldValue.Ubigeo, nil
}

// ClearUbigeo clears the value of the "ubigeo" field.
func (m *PlaceMutation) ClearUbigeo() {
	m.ubigeo = nil
	m.clearedFields[place.FieldUbigeo] = struct{}{}
}

// UbigeoCleared returns if the "ubigeo" field was cleared in this mutation.
func (m *PlaceMutation) UbigeoCleared() bool {
	_, ok := m.clearedFields[place.FieldUbigeo]
	return ok
}

// ResetUbigeo resets all changes to the "ubigeo" field.
func (m *PlaceMutation) ResetUbigeo() {
	m.ubigeo = nil
	delete(m.clearedFields, place.FieldUbigeo)
}

// SetCovidZone sets the "covidZone" field.
func (m *PlaceMutation) SetCovidZone(b bool) {
	m.covidZone = &b
}

// CovidZone returns the value of the "covidZone" field in the mutation.
func (m *PlaceMutation) CovidZone() (r bool, exists bool) {
	v := m.covidZone
	if v == nil {
		return
	}
	return *v, true
}

// OldCovidZone returns the old "covidZone" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCovidZone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCovidZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCovidZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCovidZone: %w", err)
	}
	return oldValue.CovidZone, nil
}

// ClearCovidZone clears the value of the "covidZone" field.
func (m *PlaceMutation) ClearCovidZone() {
	m.covidZone = nil
	m.clearedFields[place.FieldCovidZone] = struct{}{}
}

// CovidZoneCleared returns if the "covidZone" field was cleared in this mutation.
func (m *PlaceMutation) CovidZoneCleared() bool {
	_, ok := m.clearedFields[place.FieldCovidZone]
	return ok
}

// ResetCovidZone resets all changes to the "covidZone" field.
func (m *PlaceMutation) ResetCovidZone() {
	m.covidZone = nil
	delete(m.clearedFields, place.FieldCovidZone)
}

// SetLat sets the "lat" field.
func (m *PlaceMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *PlaceMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *PlaceMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *PlaceMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *PlaceMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[place.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *PlaceMutation) LatCleared() bool {
	_, ok := m.clearedFields[place.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *PlaceMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, place.FieldLat)
}

// SetLon sets the "lon" field.
func (m *PlaceMutation) SetLon(f float64) {
	m.lon = &f
	m.addlon = nil
}

// Lon returns the value of the "lon" field in the mutation.
func (m *PlaceMutation) Lon() (r float64, exists bool) {
	v := m.lon
	if v == nil {
		return
	}
	return *v, true
}

// OldLon returns the old "lon" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLon: %w", err)
	}
	return oldValue.Lon, nil
}

// AddLon adds f to the "lon" field.
func (m *PlaceMutation) AddLon(f float64) {
	if m.addlon != nil {
		*m.addlon += f
	} else {
		m.addlon = &f
	}
}

// AddedLon returns the value that was added to the "lon" field in this mutation.
func (m *PlaceMutation) AddedLon() (r float64, exists bool) {
	v := m.addlon
	if v == nil {
		return
	}
	return *v, true
}

// ClearLon clears the value of the "lon" field.
func (m *PlaceMutation) ClearLon() {
	m.lon = nil
	m.addlon = nil
	m.clearedFields[place.FieldLon] = struct{}{}
}

// LonCleared returns if the "lon" field was cleared in this mutation.
func (m *PlaceMutation) LonCleared() bool {
	_, ok := m.clearedFields[place.FieldLon]
	return ok
}

// ResetLon resets all changes to the "lon" field.
func (m *PlaceMutation) ResetLon() {
	m.lon = nil
	m.addlon = nil
	delete(m.clearedFields, place.FieldLon)
}

// AddOxygenrecordIDs adds the "oxygenrecords" edge to the OxygenRecord entity by ids.
func (m *PlaceMutation) AddOxygenrecordIDs(ids ...int) {
	if m.oxygenrecords == nil {
		m.oxygenrecords = make(map[int]struct{})
	}
	for i := range ids {
		m.oxygenrecords[ids[i]] = struct{}{}
	}
}

// ClearOxygenrecords clears the "oxygenrecords" edge to the OxygenRecord entity.
func (m *PlaceMutation) ClearOxygenrecords() {
	m.clearedoxygenrecords = true
}

// OxygenrecordsCleared returns if the "oxygenrecords" edge to the OxygenRecord entity was cleared.
func (m *PlaceMutation) OxygenrecordsCleared() bool {
	return m.clearedoxygenrecords
}

// RemoveOxygenrecordIDs removes the "oxygenrecords" edge to the OxygenRecord entity by IDs.
func (m *PlaceMutation) RemoveOxygenrecordIDs(ids ...int) {
	if m.removedoxygenrecords == nil {
		m.removedoxygenrecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoxygenrecords[ids[i]] = struct{}{}
	}
}

// RemovedOxygenrecords returns the removed IDs of the "oxygenrecords" edge to the OxygenRecord entity.
func (m *PlaceMutation) RemovedOxygenrecordsIDs() (ids []int) {
	for id := range m.removedoxygenrecords {
		ids = append(ids, id)
	}
	return
}

// OxygenrecordsIDs returns the "oxygenrecords" edge IDs in the mutation.
func (m *PlaceMutation) OxygenrecordsIDs() (ids []int) {
	for id := range m.oxygenrecords {
		ids = append(ids, id)
	}
	return
}

// ResetOxygenrecords resets all changes to the "oxygenrecords" edge.
func (m *PlaceMutation) ResetOxygenrecords() {
	m.oxygenrecords = nil
	m.clearedoxygenrecords = false
	m.removedoxygenrecords = nil
}

// AddBedRecordIDs adds the "bedRecords" edge to the BedRecord entity by ids.
func (m *PlaceMutation) AddBedRecordIDs(ids ...int) {
	if m.bedRecords == nil {
		m.bedRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.bedRecords[ids[i]] = struct{}{}
	}
}

// ClearBedRecords clears the "bedRecords" edge to the BedRecord entity.
func (m *PlaceMutation) ClearBedRecords() {
	m.clearedbedRecords = true
}

// BedRecordsCleared returns if the "bedRecords" edge to the BedRecord entity was cleared.
func (m *PlaceMutation) BedRecordsCleared() bool {
	return m.clearedbedRecords
}

// RemoveBedRecordIDs removes the "bedRecords" edge to the BedRecord entity by IDs.
func (m *PlaceMutation) RemoveBedRecordIDs(ids ...int) {
	if m.removedbedRecords == nil {
		m.removedbedRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbedRecords[ids[i]] = struct{}{}
	}
}

// RemovedBedRecords returns the removed IDs of the "bedRecords" edge to the BedRecord entity.
func (m *PlaceMutation) RemovedBedRecordsIDs() (ids []int) {
	for id := range m.removedbedRecords {
		ids = append(ids, id)
	}
	return
}

// BedRecordsIDs returns the "bedRecords" edge IDs in the mutation.
func (m *PlaceMutation) BedRecordsIDs() (ids []int) {
	for id := range m.bedRecords {
		ids = append(ids, id)
	}
	return
}

// ResetBedRecords resets all changes to the "bedRecords" edge.
func (m *PlaceMutation) ResetBedRecords() {
	m.bedRecords = nil
	m.clearedbedRecords = false
	m.removedbedRecords = nil
}

// AddDeathRecordIDs adds the "deathRecords" edge to the DeathRecord entity by ids.
func (m *PlaceMutation) AddDeathRecordIDs(ids ...int) {
	if m.deathRecords == nil {
		m.deathRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.deathRecords[ids[i]] = struct{}{}
	}
}

// ClearDeathRecords clears the "deathRecords" edge to the DeathRecord entity.
func (m *PlaceMutation) ClearDeathRecords() {
	m.cleareddeathRecords = true
}

// DeathRecordsCleared returns if the "deathRecords" edge to the DeathRecord entity was cleared.
func (m *PlaceMutation) DeathRecordsCleared() bool {
	return m.cleareddeathRecords
}

// RemoveDeathRecordIDs removes the "deathRecords" edge to the DeathRecord entity by IDs.
func (m *PlaceMutation) RemoveDeathRecordIDs(ids ...int) {
	if m.removeddeathRecords == nil {
		m.removeddeathRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddeathRecords[ids[i]] = struct{}{}
	}
}

// RemovedDeathRecords returns the removed IDs of the "deathRecords" edge to the DeathRecord entity.
func (m *PlaceMutation) RemovedDeathRecordsIDs() (ids []int) {
	for id := range m.removeddeathRecords {
		ids = append(ids, id)
	}
	return
}

// DeathRecordsIDs returns the "deathRecords" edge IDs in the mutation.
func (m *PlaceMutation) DeathRecordsIDs() (ids []int) {
	for id := range m.deathRecords {
		ids = append(ids, id)
	}
	return
}

// ResetDeathRecords resets all changes to the "deathRecords" edge.
func (m *PlaceMutation) ResetDeathRecords() {
	m.deathRecords = nil
	m.cleareddeathRecords = false
	m.removeddeathRecords = nil
}

// AddInfectedRecordIDs adds the "infectedRecords" edge to the InfectedRecord entity by ids.
func (m *PlaceMutation) AddInfectedRecordIDs(ids ...int) {
	if m.infectedRecords == nil {
		m.infectedRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.infectedRecords[ids[i]] = struct{}{}
	}
}

// ClearInfectedRecords clears the "infectedRecords" edge to the InfectedRecord entity.
func (m *PlaceMutation) ClearInfectedRecords() {
	m.clearedinfectedRecords = true
}

// InfectedRecordsCleared returns if the "infectedRecords" edge to the InfectedRecord entity was cleared.
func (m *PlaceMutation) InfectedRecordsCleared() bool {
	return m.clearedinfectedRecords
}

// RemoveInfectedRecordIDs removes the "infectedRecords" edge to the InfectedRecord entity by IDs.
func (m *PlaceMutation) RemoveInfectedRecordIDs(ids ...int) {
	if m.removedinfectedRecords == nil {
		m.removedinfectedRecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinfectedRecords[ids[i]] = struct{}{}
	}
}

// RemovedInfectedRecords returns the removed IDs of the "infectedRecords" edge to the InfectedRecord entity.
func (m *PlaceMutation) RemovedInfectedRecordsIDs() (ids []int) {
	for id := range m.removedinfectedRecords {
		ids = append(ids, id)
	}
	return
}

// InfectedRecordsIDs returns the "infectedRecords" edge IDs in the mutation.
func (m *PlaceMutation) InfectedRecordsIDs() (ids []int) {
	for id := range m.infectedRecords {
		ids = append(ids, id)
	}
	return
}

// ResetInfectedRecords resets all changes to the "infectedRecords" edge.
func (m *PlaceMutation) ResetInfectedRecords() {
	m.infectedRecords = nil
	m.clearedinfectedRecords = false
	m.removedinfectedRecords = nil
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *PlaceMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *PlaceMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared returns if the "region" edge to the Region entity was cleared.
func (m *PlaceMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *PlaceMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *PlaceMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *PlaceMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// SetProvinceID sets the "province" edge to the Province entity by id.
func (m *PlaceMutation) SetProvinceID(id int) {
	m.province = &id
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *PlaceMutation) ClearProvince() {
	m.clearedprovince = true
}

// ProvinceCleared returns if the "province" edge to the Province entity was cleared.
func (m *PlaceMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceID returns the "province" edge ID in the mutation.
func (m *PlaceMutation) ProvinceID() (id int, exists bool) {
	if m.province != nil {
		return *m.province, true
	}
	return
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *PlaceMutation) ProvinceIDs() (ids []int) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *PlaceMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *PlaceMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *PlaceMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared returns if the "district" edge to the District entity was cleared.
func (m *PlaceMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *PlaceMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *PlaceMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *PlaceMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.kind != nil {
		fields = append(fields, place.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, place.FieldName)
	}
	if m.politic != nil {
		fields = append(fields, place.FieldPolitic)
	}
	if m.ubigeo != nil {
		fields = append(fields, place.FieldUbigeo)
	}
	if m.covidZone != nil {
		fields = append(fields, place.FieldCovidZone)
	}
	if m.lat != nil {
		fields = append(fields, place.FieldLat)
	}
	if m.lon != nil {
		fields = append(fields, place.FieldLon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldKind:
		return m.Kind()
	case place.FieldName:
		return m.Name()
	case place.FieldPolitic:
		return m.Politic()
	case place.FieldUbigeo:
		return m.Ubigeo()
	case place.FieldCovidZone:
		return m.CovidZone()
	case place.FieldLat:
		return m.Lat()
	case place.FieldLon:
		return m.Lon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldKind:
		return m.OldKind(ctx)
	case place.FieldName:
		return m.OldName(ctx)
	case place.FieldPolitic:
		return m.OldPolitic(ctx)
	case place.FieldUbigeo:
		return m.OldUbigeo(ctx)
	case place.FieldCovidZone:
		return m.OldCovidZone(ctx)
	case place.FieldLat:
		return m.OldLat(ctx)
	case place.FieldLon:
		return m.OldLon(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case place.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case place.FieldPolitic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolitic(v)
		return nil
	case place.FieldUbigeo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUbigeo(v)
		return nil
	case place.FieldCovidZone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCovidZone(v)
		return nil
	case place.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case place.FieldLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLon(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceMutation) AddedFields() []string {
	var fields []string
	if m.addlat != nil {
		fields = append(fields, place.FieldLat)
	}
	if m.addlon != nil {
		fields = append(fields, place.FieldLon)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case place.FieldLat:
		return m.AddedLat()
	case place.FieldLon:
		return m.AddedLon()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case place.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case place.FieldLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLon(v)
		return nil
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(place.FieldPolitic) {
		fields = append(fields, place.FieldPolitic)
	}
	if m.FieldCleared(place.FieldUbigeo) {
		fields = append(fields, place.FieldUbigeo)
	}
	if m.FieldCleared(place.FieldCovidZone) {
		fields = append(fields, place.FieldCovidZone)
	}
	if m.FieldCleared(place.FieldLat) {
		fields = append(fields, place.FieldLat)
	}
	if m.FieldCleared(place.FieldLon) {
		fields = append(fields, place.FieldLon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	switch name {
	case place.FieldPolitic:
		m.ClearPolitic()
		return nil
	case place.FieldUbigeo:
		m.ClearUbigeo()
		return nil
	case place.FieldCovidZone:
		m.ClearCovidZone()
		return nil
	case place.FieldLat:
		m.ClearLat()
		return nil
	case place.FieldLon:
		m.ClearLon()
		return nil
	}
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldKind:
		m.ResetKind()
		return nil
	case place.FieldName:
		m.ResetName()
		return nil
	case place.FieldPolitic:
		m.ResetPolitic()
		return nil
	case place.FieldUbigeo:
		m.ResetUbigeo()
		return nil
	case place.FieldCovidZone:
		m.ResetCovidZone()
		return nil
	case place.FieldLat:
		m.ResetLat()
		return nil
	case place.FieldLon:
		m.ResetLon()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.oxygenrecords != nil {
		edges = append(edges, place.EdgeOxygenrecords)
	}
	if m.bedRecords != nil {
		edges = append(edges, place.EdgeBedRecords)
	}
	if m.deathRecords != nil {
		edges = append(edges, place.EdgeDeathRecords)
	}
	if m.infectedRecords != nil {
		edges = append(edges, place.EdgeInfectedRecords)
	}
	if m.region != nil {
		edges = append(edges, place.EdgeRegion)
	}
	if m.province != nil {
		edges = append(edges, place.EdgeProvince)
	}
	if m.district != nil {
		edges = append(edges, place.EdgeDistrict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeOxygenrecords:
		ids := make([]ent.Value, 0, len(m.oxygenrecords))
		for id := range m.oxygenrecords {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeBedRecords:
		ids := make([]ent.Value, 0, len(m.bedRecords))
		for id := range m.bedRecords {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeDeathRecords:
		ids := make([]ent.Value, 0, len(m.deathRecords))
		for id := range m.deathRecords {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeInfectedRecords:
		ids := make([]ent.Value, 0, len(m.infectedRecords))
		for id := range m.infectedRecords {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	case place.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case place.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedoxygenrecords != nil {
		edges = append(edges, place.EdgeOxygenrecords)
	}
	if m.removedbedRecords != nil {
		edges = append(edges, place.EdgeBedRecords)
	}
	if m.removeddeathRecords != nil {
		edges = append(edges, place.EdgeDeathRecords)
	}
	if m.removedinfectedRecords != nil {
		edges = append(edges, place.EdgeInfectedRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeOxygenrecords:
		ids := make([]ent.Value, 0, len(m.removedoxygenrecords))
		for id := range m.removedoxygenrecords {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeBedRecords:
		ids := make([]ent.Value, 0, len(m.removedbedRecords))
		for id := range m.removedbedRecords {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeDeathRecords:
		ids := make([]ent.Value, 0, len(m.removeddeathRecords))
		for id := range m.removeddeathRecords {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeInfectedRecords:
		ids := make([]ent.Value, 0, len(m.removedinfectedRecords))
		for id := range m.removedinfectedRecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedoxygenrecords {
		edges = append(edges, place.EdgeOxygenrecords)
	}
	if m.clearedbedRecords {
		edges = append(edges, place.EdgeBedRecords)
	}
	if m.cleareddeathRecords {
		edges = append(edges, place.EdgeDeathRecords)
	}
	if m.clearedinfectedRecords {
		edges = append(edges, place.EdgeInfectedRecords)
	}
	if m.clearedregion {
		edges = append(edges, place.EdgeRegion)
	}
	if m.clearedprovince {
		edges = append(edges, place.EdgeProvince)
	}
	if m.cleareddistrict {
		edges = append(edges, place.EdgeDistrict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case place.EdgeOxygenrecords:
		return m.clearedoxygenrecords
	case place.EdgeBedRecords:
		return m.clearedbedRecords
	case place.EdgeDeathRecords:
		return m.cleareddeathRecords
	case place.EdgeInfectedRecords:
		return m.clearedinfectedRecords
	case place.EdgeRegion:
		return m.clearedregion
	case place.EdgeProvince:
		return m.clearedprovince
	case place.EdgeDistrict:
		return m.cleareddistrict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	case place.EdgeRegion:
		m.ClearRegion()
		return nil
	case place.EdgeProvince:
		m.ClearProvince()
		return nil
	case place.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgeOxygenrecords:
		m.ResetOxygenrecords()
		return nil
	case place.EdgeBedRecords:
		m.ResetBedRecords()
		return nil
	case place.EdgeDeathRecords:
		m.ResetDeathRecords()
		return nil
	case place.EdgeInfectedRecords:
		m.ResetInfectedRecords()
		return nil
	case place.EdgeRegion:
		m.ResetRegion()
		return nil
	case place.EdgeProvince:
		m.ResetProvince()
		return nil
	case place.EdgeDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// ProvinceMutation represents an operation that mutates the Province nodes in the graph.
type ProvinceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	places        map[int]struct{}
	removedplaces map[int]struct{}
	clearedplaces bool
	done          bool
	oldValue      func(context.Context) (*Province, error)
	predicates    []predicate.Province
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows management of the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for the Province entity.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the ID field of the mutation.
func withProvinceID(id int) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProvinceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProvinceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvinceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvinceMutation) ResetName() {
	m.name = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *ProvinceMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *ProvinceMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared returns if the "places" edge to the Place entity was cleared.
func (m *ProvinceMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *ProvinceMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *ProvinceMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *ProvinceMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *ProvinceMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, province.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, province.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case province.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, province.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case province.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, province.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	switch name {
	case province.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	switch name {
	case province.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown Province edge %s", name)
}

// RegionMutation represents an operation that mutates the Region nodes in the graph.
type RegionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	places        map[int]struct{}
	removedplaces map[int]struct{}
	clearedplaces bool
	done          bool
	oldValue      func(context.Context) (*Region, error)
	predicates    []predicate.Region
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows management of the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for the Region entity.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the ID field of the mutation.
func withRegionID(id int) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RegionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *RegionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RegionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RegionMutation) ResetName() {
	m.name = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *RegionMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *RegionMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared returns if the "places" edge to the Place entity was cleared.
func (m *RegionMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *RegionMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *RegionMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *RegionMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *RegionMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, region.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, region.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, region.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case region.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, region.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	case region.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}
